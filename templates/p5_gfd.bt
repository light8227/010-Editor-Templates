//------------------------------------------------
//--- 010 Editor v12.0 Binary Template
//
//      File: p5_gfd.bt
//   Authors:
//   Version:
//   Purpose: GFD
//  Category: Persona 5
// File Mask: *.gmd, *.gap, *.epl, *.bed, *.gfs
//  ID Bytes: GFS0
//   History:
//------------------------------------------------

//
// --- Template options
//
//#define CFB_GAP
//#define CFB_GFS

#include "common/include.h"
#include "p5_gfd_enums.bt"
#include "p5_gfd_enum_functions.bt"

// Catherine Full Body uses features from GAP version > 0x1105100, 
// but the version in the file is listed as 0x1105090.
// GAP files from the game will not work without this enabled.
local bool CFBHack = false;

// These files are usually big endian
// Metaphor: Refantazio's files are little endian however.
BigEndian();

//
// -- Basic types
//

typedef struct
{
    char Signature[4];
    u32 Version <format=hex>;
    EFileType Type;
    u32 Reserved;
    Assert( Reserved == 0 );
} TFileHeader <read=TFileHeaderToString>;

string TFileHeaderToString( TFileHeader& value )
{
    string buffer;
    SPrintf( buffer, "%s %08X %s", value.Signature, value.Version, EnumToString( value.Type ) );
    return buffer;
}

typedef struct
{
    u32 Version<format=hex>;
    EChunkType Type;
    u32 Length;
    u32 Reserved;
    Assert( Reserved == 0 );
} TChunkHeader <read=TChunkHeaderToString>;

string TChunkHeaderToString( TChunkHeader& value )
{
    string buffer;
    SPrintf( buffer, "%08X %s", value.Version, EnumToString( value.Type ) );
    return buffer;
}

typedef struct
{
    u16 Length;
    char Str[Length];
} TString <optimize=false, read=TStringToString>;

string TStringToString( TString& value )
{
    return value.Str;
}

local uint sHashTable[256] =
{
  0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
  0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
  0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
  0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
  0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
  0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
  0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
  0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
  0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
  0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
  0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
  0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
  0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
  0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
  0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
  0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
  0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
  0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
  0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
  0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
  0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
  0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
  0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
  0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
  0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
  0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
  0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
  0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
  0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
  0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
  0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
  0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};

uint BitwiseRotateLeft( uint x, int amount )
{
  return ( x << amount ) | ( x >> ( ( 32 - amount ) & 31 ) );
}

int GenerateStringHash( char value[] )
{
  local uint len = Strlen( value );

  if ( !len )
    return 0;

  local uint hash = len;

  local int i;
  local uint tableIdx;

  for ( i = 0; i < len; i++ )
  {
    tableIdx = hash ^ ( byte )( value[i] );
    tableIdx = ( BitwiseRotateLeft( tableIdx, 2 ) & 0x000003FC ) / sizeof( uint );
    hash = BitwiseRotateLeft( hash, 24 ) & 0x00FFFFFF;
    hash ^= sHashTable[tableIdx];
  }

  return ( int )hash;
}

typedef struct(u32 version)
{
  u16 Length;

  if ( Length )
  {
    char Str[Length];

    if ( version > 0x01080000 )
    {
      u32 Hash;
    }
  }
} THashString <optimize=false, read=THashStringToString>;

typedef struct(u32 version)
{
  u16 Length;

  if ( Length )
  {
    char Str[Length];

    if ( version > 0x01080000 )
    {
      if ( version > 0x01105100 || CFBHack )
      {
        u8 Padding;
      }
      u32 Hash;
    }
  }
} THashStringGap <optimize=false, read=THashStringGapToString>;

string THashStringGapToString( THashStringGap& value )
{
    if ( value.Length == 0 )
        return "<empty string>";

    string buffer;
    SPrintf( buffer, "%s (%08X) [%08X]", value.Str, value.Hash, GenerateStringHash( value.Str ) );

    return buffer;
}

string THashStringToString( THashString& value )
{
    if ( value.Length == 0 )
        return "<empty string>";

    string buffer;
    SPrintf( buffer, "%s (%08X) [%08X]", value.Str, value.Hash, GenerateStringHash( value.Str ) );

    return buffer;
}

typedef struct(u32 version)
{
    u16 Length;
    if ( Length )
    {
        char Str[Length];

        if ( version > 0x1080000 )
        {
            // hash
            u32 Hash;
        }
    }
} THashStringNoPad <optimize=false>;

typedef struct(u32 version)
{
    u32 PropertyCount;
    struct TUserProperty Properties( version )[PropertyCount];
} TUserPropertyDictionary <optimize=false>;

typedef struct
{
    byte X, Y, Z;
} TByteVector3;

typedef struct
{
    byte X, Y, Z;
} TByteVector4;

typedef struct( u32 version )
{
    EUserPropertyValueType Type;
    THashString Name( version );
    u32 Size;

    switch ( Type )
    {
        case EUserPropertyValueType_Int: s32 Value; break;
        case EUserPropertyValueType_Float: f32 Value; break;
        case EUserPropertyValueType_Bool: bool Value; break;
        case EUserPropertyValueType_String: char Value[ Size - 1 ]; break;
        case EUserPropertyValueType_ByteVector3: struct TByteVector3 Value; break;
        case EUserPropertyValueType_ByteVector4: struct TByteVector4 Value; break;
        case EUserPropertyValueType_Vector3: TVector3 Value; break;
        case EUserPropertyValueType_Vector4: TVector4 Value; break;
        case EUserPropertyValueType_ByteArray: u8 Value[ Size ]; break;
        default: Assert( false, "Unknown user property type" );
    }
} TUserProperty <optimize=false, read=TUserPropertyToString>;

string TUserPropertyToString( TUserProperty& value )
{
    string buffer;
    switch ( value.Type )
    {
        case EUserPropertyValueType_Int: SPrintf( buffer, "%s = int(%d)", value.Name.Str, value.Value ); break;
        case EUserPropertyValueType_Float: SPrintf( buffer, "%s = float(%f)", value.Name.Str, value.Value ); break;
        case EUserPropertyValueType_Bool: SPrintf( buffer, "%s = bool(%d)", value.Name.Str, value.Value ); break;
        case EUserPropertyValueType_String: SPrintf( buffer, "%s = string(%s)", value.Name.Str, value.Value ); break;
        case EUserPropertyValueType_ByteVector3: SPrintf( buffer, "%s = bytevector3(...)", value.Name.Str ); break;
        case EUserPropertyValueType_ByteVector4: SPrintf( buffer, "%s = bytevector4(...)", value.Name.Str ); break;
        case EUserPropertyValueType_Vector3: SPrintf( buffer, "%s = vector3(%s)", value.Name.Str, TVector3ToString( value.Value ) ); break;
        case EUserPropertyValueType_Vector4: SPrintf( buffer, "%s = vector4(%s)", value.Name.Str, TVector4ToString( value.Value ) ); break;
        case EUserPropertyValueType_ByteArray: SPrintf( buffer, "%s = bytearray(...)", value.Name.Str ); break;
        default: Assert( false, "Unknown user property type" );
    }
    return buffer;
}

//
// -- End Basic types --
//

//
// -- Texture types --
//

typedef struct
{
    SetRandomBackColor();

    TString Name;
    ETextureFormat Format;
    u32 Size;
    u8 Data[Size];
    u8 Field1C;
    u8 Field1D;
    u8 Field1E;
    u8 Field1F;
} TTexture <optimize=false, read=TTextureToString>;

string TTextureToString( TTexture& value )
{
    string buffer;
    SPrintf( buffer, "%s (%s)", TStringToString( value.Name ), EnumToString( value.Format ) );
    return buffer;
}

typedef struct
{
    SetRandomBackColor();

    TChunkHeader Header;
    Assert( Header.Type == EChunkType_TextureDictionary );

    u32 TextureCount;
    if ( TextureCount > 0 )
        TTexture Textures[TextureCount];
} TTextureDictionary <optimize=false, read=Str("%d textures", TextureCount)>;

//
// -- End Texture types --
//

//
// -- Material types --
//

typedef struct
{
    SetRandomBackColor();

    TChunkHeader Header;
    Assert( Header.Type == EChunkType_MaterialDictionary );

    u32 MaterialCount;
    struct TMaterial Materials( Header.Version )[MaterialCount];
} TMaterialDictionary <optimize=false, read=Str("%d materials", MaterialCount)>;

typedef enum<u8>
{
    HighlightMaterialLerp = 1,
    HighlightMaterialAddition = 2,
    HighlightMaterialSubtract = 3,
    HighlightMaterialModulate = 4,
} EHighlightMapModulationMode;

typedef enum<u16>
{
    AlphaTest0 = 0,
    AlphaTestLessThan = 1,
    AlphaTest1 = 2,
    AlphaTestLessThan2 = 3,
    AlphaTestGreaterThan = 4,
    AlphaTest2 = 5,
    AlphaTestGreatherThan2 = 6,
} EAlphaColorsTest;

typedef struct(u32 version)
{
    TVector4 Diffuse;
    f32 Reflectivity;
    f32 Diffusivity;
    f32 Unk1;
    if (version >= 0x2000004) {
        f32 Unk2;
    }
    if (version >= 0x2030001) {
        f32 Unk3;
    }
    if (version > 0x2110040) {
        u32 Unk4;
    }
    if (version == 0x2110140) {
        f32 Unk5;
    }
} TMaterialParameterSetType0;

typedef struct(u32 version)
{
    TVector4 AmbientColor;
    TVector4 DiffuseColor;
    TVector4 SpecularColor;
    TVector4 EmissiveColor;
    f32 matReflectivity; // reflectivity
    f32 matOutlineIndex; // diffiusivity
} TMaterialParameterSetType1;

typedef struct(u32 version)
{
    TVector4 BaseColor;
    TVector4 P2_1;
    TVector4 EdgeColor;
    TVector4 EmissiveColor;
    TVector3 P2_4;
    f32 P2_5[6];
    u32 P2_6;
    if ( version >= 0x200ffff ) {
        f32 P2_7;
        TVector3 P2_8;
    }
    if ( version >= 0x2030001 )
        f32 P2_9;
    if ( version >= 0x2090000 )
        f32 P2_10;
    if ( version >= 0x2094001 )
        f32 P2_11;
    if ( version >= 0x2109501 )
        f32 P2_12[3];
    if ( version >= 0x2109601 )
        f32 P2_14;
    if ( version >= 0x2110197 )
        f32 P2_15;
    if ( version >= 0x2110203 )
        f32 P2_16;
    if ( version >= 0x2110209 )
        f32 P2_17;
} TMaterialParameterSetType2_3_13;

typedef struct(u32 version)
{
    TVector4 P4_0;
    TVector4 P4_1;
    TVector3 P4_2;
    u32 P4_3;
    if ( version >= 0x2110184 )
        f32 P4_4;
    if ( version >= 0x2110203 )
        f32 P4_5;
    if ( version >= 0x2110217 )
        f32 P4_6;
} TMaterialParameterSetType4;

typedef struct(u32 version)
{
    struct {
        TVector4 Field0;
        f32 Field1;
        f32 Field2;
        f32 Field3;
        f32 Field4;
    } P6_0[2];
    f32 P6_1;
    if ( version >= 0x2110021 )
    {
        f32 P6_2;
        f32 P6_3;
    }
    f32 P6_4;
    f32 P6_5;
} TMaterialParameterSetType6;

typedef struct(u32 version)
{
    TVector4 P12_0;
    TVector4 P12_1;
    TVector4 P12_2;
    f32 P12_3;
    f32 P12_4;
    f32 P12_5;
    u32 P12_6;
    f32 P12_7;
    TVector3 P12_8;
    f32 P12_9;
    f32 P12_10;
    if ( version >= 0x2109501 )
    {
        f32 P12_11;
        f32 P12_12;
        f32 P12_13;
    }
    if ( version >= 0x2109601 )
        f32 P12_14;
    if ( version >= 0x2109701 )
    {
        TVector3 P12_15;
        f32 P12_16;
        f32 P12_17;
        f32 P12_18;
        f32 P12_19;
    }
    if ( version >= 0x2110070 )
    {
        TVector4 P12_20;
        f32 P12_21;
        f32 P12_22;
    }
} TMaterialParameterSetType12;

typedef struct(u32 version)
{
    if ( version <= 0x1103040 )
    {
        s16 _Type;
        local EMaterialDrawMethod Type = (EMaterialDrawMethod)_Type;
        s16 SrcColor;
        s16 DstColor; 
        s16 SrcAlpha;
        s16 DstAlpha; 

        // verification needed: previously 0x108011B
        if ( version > 0x1080003 )
        {
            s16 Multiple; 
        }
    }
    else
    {
        EMaterialDrawMethod Type;
        u8 SrcColor;
        u8 DstColor;
        u8 SrcAlpha;
        u8 DstAlpha;
        EHighlightMapModulationMode Multiple;
    }
} TMaterialBlend; // gfdMaterialBlend

typedef struct
{
    s16 ClipThresholdTest; // AlphaTestRef
    EAlphaColorsTest Function;
} TMaterialAlphaTest; // gfdMaterialAlphaTest

typedef struct
{
    TMaterialMapsTexcoord In;
    TMaterialMapsTexcoord Out;
} TShaderIDTexCoord; // gfdShaderIDTexcoord

typedef struct
{
    EShaderType Type;
    TShaderIDTexCoord TexCoord;
} TShaderID; // gfdShaderId

typedef struct
{
    TShaderID ID;
} TMaterialShader; // gfdMaterialShader

typedef struct(u32 version)
{
    SetRandomBackColor();
    local u16 MaterialParameterVersion = 1;
    if (version >= 0x2000000) {
        u16 _MaterialParameterVersion;
        MaterialParameterVersion = _MaterialParameterVersion;
    }
    THashString Name( version );
    EMaterialFlags Flags;

    if ( version < 0x1104000 )
    {
        local EMaterialFlags RuntimeFlags = ( EMaterialFlags )( ( u32 )Flags & 0x7FFFFFFF );
    }
    
    if (version < 0x2000000) {
        TVector4 AmbientColor;
        TVector4 DiffuseColor;
        TVector4 SpecularColor;
        TVector4 EmissiveColor;
        f32 Reflectivity;
        f32 Diffusivity;
    } else {
        switch (MaterialParameterVersion) {
            case 0:
                TMaterialParameterSetType0 MaterialParameterSet(version);
                break;
            case 1:
                TMaterialParameterSetType1 MaterialParameterSet(version);
                break;
            case 2:
            case 3:
            case 0xd:
                TMaterialParameterSetType2_3_13 MaterialParameterSet(version);
                break;
            case 4:
                TMaterialParameterSetType4 MaterialParameterSet(version);
                break;
            case 6:
                TMaterialParameterSetType6 MaterialParameterSet(version);
                break;
            case 12:
                TMaterialParameterSetType12 MaterialParameterSet(version);
                break;
            default:
                Assert(false, Str("Unimplemented material parameter version: %d", MaterialParameterVersion));
                break;
        }
    }
    
    TMaterialBlend Blend(version);
    TMaterialAlphaTest AlphaTest;

    if ( version <= 0x1104800 )
    {
        local s16 Flags2 = 1;
        // verification needed: previously s16
        s32 SortPriority;
    }
    else
    {
        EMaterialFlags2 Flags2;
        s16 SortPriority;
    }
    
    TMaterialShader Shader;

    TBool16 DisableBackfaceCulling;
    if ( version > 0x1103040) 
    {
        u32 Constant<format=hex>;
    }
    if (version >= 0x2110160) 
    {
        f32 Unk7;
    }
    if (Flags & EMaterialFlags_Texture1 ) struct TTextureMap Texture1( version ) <name="Texture1 (Diffuse)">; // diffuse
    if (Flags & EMaterialFlags_Texture2 ) struct TTextureMap Texture2( version ) <name="Texture2 (Normal)">; // normal
    if (Flags & EMaterialFlags_Texture3 ) struct TTextureMap Texture3( version ) <name="Texture3 (Specular)">; // specular
    if (Flags & EMaterialFlags_Texture4 ) struct TTextureMap Texture4( version ) <name="Texture4 (Reflection)">; // reflection
    if (Flags & EMaterialFlags_Texture5 ) struct TTextureMap Texture5( version ) <name="Texture5 (Multiple)">; // highlight
    if (Flags & EMaterialFlags_Texture6 ) struct TTextureMap Texture6( version ) <name="Texture6 (Glow)">; // glow
    if (Flags & EMaterialFlags_Texture7 ) struct TTextureMap Texture7( version ) <name="Texture7 (Dark)">; // night
    if (Flags & EMaterialFlags_Texture8 ) struct TTextureMap Texture8( version ) <name="Texture8 (Detail)">; // detail
    if (Flags & EMaterialFlags_Texture9 ) struct TTextureMap Texture9( version ) <name="Texture9 (Light)">; // shadow map
    if (Flags & EMaterialFlags_Texture10 ) struct TTextureMap Texture10( version ) <name="Texture10 (Reserve)">;

    local ShaderFlags shaderFlag;

    if (Flags & EMaterialFlags_Extension )
    {
        u32 AttributeCount;

        local u32 i;
        local u32 attributeStart;
        local u32 attributeHeader;

        for (i = 0; i < AttributeCount; ++i)
        {
            attributeStart = FTell();
            attributeHeader = ReadInt( attributeStart );

            switch ( ( enum EMaterialAttributeType )( attributeHeader & 0xFFFF ) )
            {
                case EMaterialAttributeType_ToonShading: {
                    struct TMaterialAttributeToonShading Attribute( version, shaderFlag );
                    // if (Attribute.MaterialFlags & EMaterialAttributeToonShadingFlags_Bit0 && MaterialFlags & EMaterialFlags_HasNormalMap  ) 
                    //     shaderFlag.FLAG2 |= 0x2000;
                    // if (Attribute.MaterialFlags & EMaterialAttributeToonShadingFlags_Bit1 ) 
                    //     shaderFlag.FLAG2 |= 0x100000;
                    // if (Attribute.MaterialFlags & EMaterialAttributeToonShadingFlags_Bit2 && MaterialFlags & EMaterialFlags_HasNormalMap  )   
                    //     shaderFlag.FLAG2 |= 0x200000;
                    // if (Attribute.MaterialFlags & EMaterialAttributeToonShadingFlags_Bit3 )
                    //     shaderFlag.FLAG2 |= 0x400000;
                    // if (Attribute.MaterialFlags & EMaterialAttributeToonShadingFlags_Bit4 && MaterialFlags & EMaterialFlags_HasNormalMap  )
                    //     shaderFlag.FLAG2 |= 0x4000000;
                    // if (Attribute.MaterialFlags & EMaterialAttributeToonShadingFlags_Bit5 )
                    //     shaderFlag.FLAG2 |= 0x8000000; 
                    // if (Attribute.MaterialFlags & EMaterialAttributeToonShadingFlags_Bit6 && MaterialFlags & EMaterialFlags_HasShadowMap  )
                    //     shaderFlag.FLAG1 |= 0x10000;
                    break;
                }
                case EMaterialAttributeType_InnerGlow: {
                    struct TMaterialAttributeInnerGlow Attribute( version, shaderFlag );
                    /*
                    if (Attribute.Flags.EMaterialAttributeInnerGlowFlags_Bit31 && MaterialFlags.TMaterialFlags_HasNormalMap) shaderFlag.FLAG2 |= 0x2000;
                    if (Attribute.Flags.EMaterialAttributeInnerGlowFlags_Bit30) shaderFlag.FLAG2 |= 0x80000;
                    if (Attribute.Flags.EMaterialAttributeInnerGlowFlags_Bit29) shaderFlag.FLAG2 |= 0x100000;
                    if (Attribute.Flags.EMaterialAttributeInnerGlowFlags_Bit28 && MaterialFlags.TMaterialFlags_HasHighlightMap) shaderFlag.FLAG2 |= 0x800000;
                    if (Attribute.Flags.EMaterialAttributeInnerGlowFlags_Bit27 && MaterialFlags.TMaterialFlags_HasNormalMap) shaderFlag.FLAG2 |= 0x4000000;
                    if (Attribute.Flags.EMaterialAttributeInnerGlowFlags_Bit25) shaderFlags.FLAG2 |= 0x8000000;
                    if (Attribute.Flags.EMaterialAttributeInnerGlowFlags_Bit24 && MaterialFlags.TMaterialFlags_HasShadowMap) shaderFlag.FLAG1 |= 0x10000;
                    */
                    break;
                }
                case EMaterialAttributeType_Outline: {
                    struct TMaterialAttributeOutline Attribute( version, shaderFlag ); 
                    // if (/*ENVFlags & CharacterOutline*/ MaterialFlags.TMaterialFlags_HasOutline && DrawMethod == EMaterialDrawMethod_Opaque
                    //     && DiffuseColor.W == 1.0 && (Field98 == -1 || Field94 & Bit7)) {
                    // shaderFlag.FLAG0 |= 0x40000000;
                    // }
                    break;
                }
                case EMaterialAttributeType_Type3: struct TMaterialAttributeWater Attribute( version, shaderFlag ); break;
                case EMaterialAttributeType_Type4: {
                    struct TMaterialAttributeScrollingTexture Attribute( version, shaderFlag );
                    //if (Attribute.MaterialFlags.TMaterialAttributeScrolingTexture
                    break;
                }
                case EMaterialAttributeType_Type5: struct TMaterialAttributeType5 Attribute( version, shaderFlag ); break;
                case EMaterialAttributeType_Type6: struct TMaterialAttributeType6 Attribute( version, shaderFlag ); break;
                case EMaterialAttributeType_Type7: struct TMaterialAttributeType7 Attribute( version, shaderFlag ); break;
                case EMaterialAttributeType_Type8: struct TMaterialAttributeAlphaCrunch Attribute( version, shaderFlag ); break;
                default:
                    local string buffer;
                    SPrintf( buffer, "Unknown material attribute type %01d", ( attributeHeader & 0xFFFF ) );
                    Assert( false, buffer );
                    break;
            }
        }
    }
} TMaterial <optimize=false, read=TMaterialToString(this, shaderFlag)>;

u32 TexcoordFlagToInt(TMaterialMapsTexcoord& val)
{
    u32 texcoordValue = val.DiffuseMap;
    texcoordValue += val.NormalMap << 3;
    texcoordValue += val.SpecularMap << 6;
    texcoordValue += val.ReflectionMap << 9;
    texcoordValue += val.HighlightMap << 12;
    texcoordValue += val.GlowMap << 15;
    texcoordValue += val.NightMap << 18;
    texcoordValue += val.DetailMap << 21;
    texcoordValue += val.ShadowMap << 24;
    texcoordValue += val.Filler << 27;
    return texcoordValue;
}

string TMaterialToString( TMaterial& value, ShaderFlags& attributeFlags )
{
    string buffer;
    SPrintf(buffer, "%s", value.Name.Str);
    return buffer;
    u32 shaderFlags[4] = 0;
    // get shader data
    // this assumes that the scene contains one directional light (FLAG0_LIGHT0_DIRECTION)
    shaderFlags[1] |= 0x2;
    if (value.MaterialFlags & EMaterialFlags_EnableGlobalLight) {
        shaderFlags[0] |= 0x10; // FLAG0_LIGHT0_DIRECTION
        if (value.DrawMethod == EMaterialDrawMethod_Opaque && value.DiffuseColor.W >= 1.0 && (value.Field98 == -1 || value.Field94 & Bit7) 
            && (value.Field94 & Bit12 || value.SpecularColor.W >= 1.0) /*&& value.Field94 & Bit3*/) {
            shaderFlags[0] |= 0x20000000; // FLAG0_DEFERRED
        }
        if (value.MaterialFlags & EMaterialFlags_HasShadowMap)    {
            shaderFlags[1] |= 0x802; // FLAG1_MATERIAL_LIGHT
            if (value.Field94 & LightMapModulate2) {
                if (value.Field94 & LightMapModulate2) shaderFlags[1] |= 0x20802; // FLAG1_LIGHTMAP_MODULATE2, FLAG1_MATERIAL_LIGHT
            } else {
                shaderFlags[2] |= 0x4; // FLAG2_LIGHTMAP_MODULATE
            }
        }
    }
    shaderFlags[0] |= 0x4000;
    if (value.MaterialFlags & EMaterialFlags_AlphaTest)   {
        switch (value.envColorsAlphaTest)   {
            case 0:         shaderFlags[2] |= 0x8; break;
            case 1: case 3: shaderFlags[2] |= 0x40; break;
            case 2:         shaderFlags[2] |= 0x10; break;
            case 4: case 6: shaderFlags[2] |= 0x80; break;
            case 5:         shaderFlags[2] |= 0x20; break;
            default: {
                local string buffer;
                SPrintf( buffer, "Unknown envColorsAlphaTest value %d", value.envColorsAlphaTest);
                Assert(false, "Unknown envColorsAlphaTest value"); 
                break;
            }
        }
    }
    if (value.MaterialFlags & EMaterialFlags_MaterialAmbient && value.EmissiveColor.W > 0) shaderFlags[1] |= 0x10; // FLAG1_MATERIAL_EMISSIVE
    if (value.MaterialFlags & EMaterialFlags_HasVertexColors) shaderFlags[1] |= 0x100;
    //if (value.Field94 & Bit8) shaderFlags[1] |= 0x4;
    if (value.MaterialFlags & EMaterialFlags_MaterialSpecular) shaderFlags[1] |= 0x4; // FLAG1_MATERIAL_SPECULAR

    if (value.MaterialFlags & EMaterialFlags_Bit5) {
        /*if (ENVFlags.Fog)*/ shaderFlags[1] |= 0x20;
        /*if (ENVFlags.FloorFog)*/ shaderFlags[1] |= 0x8000;
        if (value.DrawMethod == EMaterialDrawMethod_BlackAsAlpha) shaderFlags[2] |= 0x1000;
    }

    if (value.MaterialFlags & EMaterialFlags_HasHighlightMap) {
        switch (value.HighlightMapModulationMode) {
            case HighlightMaterialLerp: shaderFlags[2] |= 0x200;
            case HighlightMaterialAddition: shaderFlags[2] |= 0x400;
            case HighlightMaterialSubtract: shaderFlags[2] |= 0x800;
            case HighlightMaterialModulate: shaderFlags[3] |= 0x2;
        }
    }

    if (value.MaterialFlags & EMaterialFlags_HasReflectionMap && value.MaterialFlags & EMaterialFlags_Bit9) {
        shaderFlags[1] |= 0x40; // FLAG1_MATERIAL_REFLECTION
        /* if (value.ReflectionMap.Texture->textureContents->shaderInstance->Field10 > 9 && */shaderFlags[2] |= 0x100;/* && FakeReflectionType == 1) {
            shaderFlags[3] |= 0x1; // FLAG3_REFLECT_TYPE1
        } */
        if (value.matReflectivity < 1) shaderFlags[1] |= 0x80; // FLAG1_MATERIAL_REFLECTION_LERP
        if (value.Field94 & Bit8) shaderFlags[1] |= 0x40000; // FLAG1_MATERIAL_REFLECTION_ADD
    }

    if (/*ENVFlags.FieldShadow && */value.MaterialFlags & EMaterialFlags_ReceiveShadow) {
        shaderFlags[1] |= 0x1; // FLAG1_MATERIAL_SHADOW
        // if (shadowRenderType == 3) {
            shaderFlags[2] |= 0x40000000; // FLAG2_CSM (probably)
            //if (PCFMode == 1) {
                shaderFlags[2] |= 0x1000000; // FLAG2_PCF_4x4 (probably)
            //}
        //}
        // if (ShadowConst2 & 4 != 0) {
            shaderFlags[2] |= 0x20000000; // FLAG2_PCF (probably)
        //}
    }

    // TextureMaps
    if (value.MaterialFlags & EMaterialFlags_HasDiffuseMap    ) { shaderFlags[1] |= 0x400000;    shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.DiffuseMap | 0x10000 << value.TexcoordFlags1.DiffuseMap;        }  // FLAG1_TEXTURE1
    if (value.MaterialFlags & EMaterialFlags_HasNormalMap     ) { shaderFlags[1] |= 0x800000;    shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.NormalMap | 0x10000 << value.TexcoordFlags1.NormalMap;          }// FLAG1_TEXTURE2
    if (value.MaterialFlags & EMaterialFlags_HasSpecularMap   ) { shaderFlags[1] |= 0x1000000;   shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.SpecularMap | 0x10000 << value.TexcoordFlags1.SpecularMap;      } // FLAG1_TEXTURE3
    if (value.MaterialFlags & EMaterialFlags_HasReflectionMap ) { shaderFlags[1] |= 0x2000000;   shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.ReflectionMap | 0x10000 << value.TexcoordFlags1.ReflectionMap;  } // FLAG1_TEXTURE4
    if (value.MaterialFlags & EMaterialFlags_HasHighlightMap  ) { shaderFlags[1] |= 0x4000000;   shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.HighlightMap | 0x10000 << value.TexcoordFlags1.HighlightMap;    } // FLAG1_TEXTURE5
    if (value.MaterialFlags & EMaterialFlags_HasGlowMap       ) { shaderFlags[1] |= 0x8000000;   shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.GlowMap | 0x10000 << value.TexcoordFlags1.GlowMap;              } // FLAG1_TEXTURE6
    if (value.MaterialFlags & EMaterialFlags_HasNightMap      ) { shaderFlags[1] |= 0x10000000;  shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.NightMap | 0x10000 << value.TexcoordFlags1.NightMap;            }// FLAG1_TEXTURE7
    if (value.MaterialFlags & EMaterialFlags_HasDetailMap     ) { shaderFlags[1] |= 0x20000000;  shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.DetailMap | 0x10000 << value.TexcoordFlags1.DetailMap;          } // FLAG1_TEXTURE8
    if (value.MaterialFlags & EMaterialFlags_HasShadowMap     ) { shaderFlags[1] |= 0x40000000;  shaderFlags[0] |= 0x80000 << value.TexcoordFlags0.ShadowMap | 0x10000 << value.TexcoordFlags1.ShadowMap;          } // FLAG1_TEXTURE9

    if (value.MaterialFlags & EMaterialFlags_UVTransform) {
        if (value.DiffuseMap.HasUVTransform)       shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.DiffuseMap;
        if (value.NormalMap.HasUVTransform)        shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.NormalMap;
        if (value.SpecularMap.HasUVTransform)      shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.SpecularMap;
        if (value.ReflectionMap.HasUVTransform)    shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.ReflectionMap;
        if (value.HighlightMap.HasUVTransform)     shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.HighlightMap;
        if (value.GlowMap.HasUVTransform)          shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.GlowMap;
        if (value.NightMap.HasUVTransform)         shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.NightMap;
        if (value.DetailMap.HasUVTransform)        shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.DetailMap;
        if (value.ShadowMap.HasUVTransform)        shaderFlags[1] |= 0x1000 << value.TexcoordFlags1.ShadowMap;
    }

    if (value.MaterialFlags & EMaterialFlags_Bit18) shaderFlags[2] |= 0x4000;

    shaderFlags[0] |= attributeFlags.FLAG0;
    shaderFlags[1] |= attributeFlags.FLAG1;
    shaderFlags[2] |= attributeFlags.FLAG2;
    shaderFlags[3] |= attributeFlags.FLAG3;

    if (value.Field94 & Bit7 || value.DrawMethod == EMaterialDrawMethod_Opaque || value.DiffuseColor.W < 1.0f 
        || (value.Field98 != -1 && value.Field94 & Bit7 == 0) || value.Field94 & Bit12) {
        if (value.MaterialFlags & EMaterialFlags_UVTransform || /*ENVFlags & 0x20000000 */ true) shaderFlags[0] |= 0x8000;
    }

    if (value.MaterialFlags & EMaterialFlags_DisableBloom) shaderFlags[2] |= 0x8000;
    if (value.Field94 & Bit9) shaderFlags[0] |= 0x2000000;
    

    SPrintf( buffer, "%x_%x_%x_%x_%x_%x_%x \t %s", value.ShaderType, shaderFlags[0], shaderFlags[1], shaderFlags[2], shaderFlags[3], TexcoordFlagToInt(value.TexcoordFlags0), TexcoordFlagToInt(value.TexcoordFlags1), THashStringToString( value.Name ));
    //SPrintf( buffer, "%s", THashStringToString( value.Name ) );
    return buffer;
}

typedef struct( u32 version )
{
    SetBackColorToShadeOfLastColor( 0x10 );

    THashString Name( version );
    s32 Field44;
    TBool8 HasUVTransform;
    TBool8 HasTextureFiltering <name = "Has Texture Filtering">;
    u8 Field4A;
    u8 Field4B;
    TMatrix4x4 UVTransform;
} TTextureMap <optimize=false, read=TTextureMapToString>;

string TTextureMapToString( TTextureMap& value )
{
    string buffer;
    SPrintf( buffer, "%s", THashStringToString( value.Name ) );
    return buffer;
}

typedef struct
{
    EMaterialAttributeFlags Flags : 16;
    EMaterialAttributeType Type : 16;
} TMaterialAttributeHeader;

typedef struct(u32 version, ShaderFlags& shaderFlag )
{
    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_ToonShading );

    if ( version > 0x1104500 )
    {
        TVector4 Color;
        f32 toonLightThrehold;
        f32 toonLightFactor;
        f32 toonLightBrightness;
        f32 toonShadowThreshold;
        f32 toonShadowFactor;
        //local EMaterialAttributeToonShadingFlags Flags;
        EMaterialAttributeToonShadingFlags MaterialFlags;
        /*
        if (MaterialFlags.TMaterialAttributeToonShadingFlags_Bit0)   shaderFlag.FLAG2 |= 0x2000; // If there's a normal map
        if (MaterialFlags.TMaterialAttributeToonShadingFlags_Bit1)   shaderFlag.FLAG2 |= 0x100000;
        if (MaterialFlags.TMaterialAttributeToonShadingFlags_Bit2)   shaderFlag.FLAG2 |= 0x200000; // If there's a normal map
        if (MaterialFlags.TMaterialAttributeToonShadingFlags_Bit3)   shaderFlag.FLAG2 |= 0x400000;
        if (MaterialFlags.TMaterialAttributeToonShadingFlags_Bit4)   shaderFlag.FLAG2 |= 0x4000000; // If there's a normal map
        if (MaterialFlags.TMaterialAttributeToonShadingFlags_Bit5)   shaderFlag.FLAG2 |= 0x8000000; 
        if (MaterialFlags.TMaterialAttributeToonShadingFlags_Bit6)   shaderFlag.FLAG1 |= 0x10000; // If there's a shadow map
        */
        
    }
    else if ( version > 0x1104220 )
    {
        TVector4 Color;
        f32 toonLightThrehold;
        f32 toonLightFactor;
        f32 toonLightBrightness;
        f32 toonShadowThreshold;
        f32 toonShadowFactor;

        local EMaterialAttributeToonShadingFlags Flags;
        bool Flag1;
        bool Flag2;
        bool Flag4;

        if ( Version > 0x1102460 )
        {
            bool Flag8;
        }

        if ( Flag1 )
            Flags |= EMaterialAttributeToonShadingFlags_Bit0;

        if ( Flag2 )
            Flags |= EMaterialAttributeToonShadingFlags_Bit1;

        if ( Flag4 )
            Flags |= EMaterialAttributeToonShadingFlags_Bit2;

        if ( Version > 0x1104260 )
        {
            if ( Flag8 )
                Flags |= EMaterialAttributeToonShadingFlags_Bit3;
        }
    }
    else
    {
        TVector4 Color;
        f32 toonLightThrehold;
        f32 toonLightFactor;
        // verification needed: previously a local, not read frm file
        f32 toonLightBrightness;
        f32 toonShadowThreshold;
        f32 toonShadowFactor;
    }
} TMaterialAttributeToonShading <optimize=false>;

typedef struct(u32 version, ShaderFlags& shaderFlag )
{
    SetBackColorToShadeOfLastColor( 0x10 );

    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_InnerGlow );

    TVector4 edgeLightColor;
    f32 edgeLightThreshold;
    f32 edgeLightFactor;
    TVector4 edgeShadowColor;
    f32 edgeShadowThreshold;
    f32 edgeShadowFactor;

    if ( version <= 0x1104500 )
    {
        local EMaterialAttributeInnerGlowFlags Flags;

        bool Flag1;
        if ( Flag1 )
            Flags |= EMaterialAttributeInnerGlowFlags_Bit0;

        if ( version > 0x1104180 )
        {
            bool Flag2;
            if ( Flag2 )
                Flags |= EMaterialAttributeInnerGlowFlags_Bit1;
        }

        if ( version > 0x1104210 )
        {
            bool Flag4;
            if ( Flag4 )
                Flags |= EMaterialAttributeInnerGlowFlags_Bit2;
        }

        if ( Version > 0x1104400 )
        {
            bool Flag8;
            if ( Flag8 )
                Flags |= EMaterialAttributeInnerGlowFlags_Bit3;
        }
    }
    else
    {
        EMaterialAttributeInnerGlowFlags Flags;
        /*
        if (Flags.EMaterialAttributeInnerGlowFlags_Bit6) shaderFlags.FLAG2 |= 0x8000000;
        if (Flags.EMaterialAttributeInnerGlowFlags_Bit0) shaderFlag.FLAG2 |= 0x2000; // If there's a normal map
        if (Flags.EMaterialAttributeInnerGlowFlags_Bit4) shaderFlag.FLAG2 |= 0x4000000; // If there's a normal map
        if (Flags.EMaterialAttributeInnerGlowFlags_Bit7) shaderFlag.FLAG1 |= 0x10000; // If there's a shadow map
        if (Flags.EMaterialAttributeInnerGlowFlags_Bit1) shaderFlag.FLAG2 |= 0x80000;
        if (Flags.EMaterialAttributeInnerGlowFlags_Bit2) shaderFlag.FLAG2 |= 0x100000;
        if (Flags.EMaterialAttributeInnerGlowFlags_Bit3) shaderFlag.FLAG2 |= 0x800000; // If there's a highlight map
        */
        
    }
} TMaterialAttributeInnerGlow <optimize=false>;

typedef struct(u32 version, ShaderFlags& shaderFlags )
{
    SetBackColorToShadeOfLastColor( 0x10 );

    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_Outline );

    s32 Category;
    s32 Color;
} TMaterialAttributeOutline;

typedef struct(u32 version, ShaderFlags& shaderFlag)
{
    SetBackColorToShadeOfLastColor( 0x10 );

    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_Type3 );
    TVector3 waterWaveLength;
    f32 waterTime;
    TVector3 waterAmplitude;
    f32 reflectAlpha;
    TVector3 waterSpeed;
    f32 refractRatio;
    EMaterialAttributeWaterFlags waterFlags;
    if (waterFlags & EMaterialAttributeWaterFlags_WaterReflection) shaderFlags.FLAG2 |= 0x10000;
    if (waterFlags & EMaterialAttributeWaterFlags_Bit1) shaderFlags.FLAG2 |= 0x20000;
    if (waterFlags & EMaterialAttributeWaterFlags_WaterFresnel) shaderFlags.FLAG2 |= 0x40000;
    
} TMaterialAttributeWater;

typedef struct(u32 version, ShaderFlags& shaderFlags)
{
    SetBackColorToShadeOfLastColor( 0x10 );

    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_Type4 );

    TVector4 edgeLightColor;
    f32 edgeLightThreshold;
    f32 edgeLightFactor;
    TVector4 edgeShadowColor;
    f32 edgeShadowThreshold;
    f32 edgeShadowFactor;
    f32 Field3C;
    f32 Field40;
    f32 Field44;
    f32 Field48;
    f32 Field4C;
    u8 Field50;
    f32 Field54;
    f32 Field58;
    EMaterialAttributeScrollingTextureFlags ScrollTexFlags;
} TMaterialAttributeScrollingTexture;

typedef struct(u32 version, ShaderFlags& shaderFlags)
{
    SetBackColorToShadeOfLastColor( 0x10 );

    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_Type5 );

    s32 Field0C;
    s32 Field10;
    f32 Field14;
    f32 Field18;
    TVector4 Field1C;
    f32 Field2C;
    f32 Field30;
    f32 Field34;
    f32 Field38;
    f32 Field3C;
    TVector4 Field48;
} TMaterialAttributeType5;

typedef struct(u32 version, ShaderFlags& shaderFlags)
{
    SetBackColorToShadeOfLastColor( 0x10 );

    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_Type6 );

    u32 Field0C;
    u32 Field10;
    u32 Field14;
} TMaterialAttributeType6;

typedef struct(u32 version, ShaderFlags& shaderFlags)
{
    SetBackColorToShadeOfLastColor( 0x10 );

    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_Type7 );
} TMaterialAttributeType7;

typedef struct(u32 version, ShaderFlags& shaderFlags)
{
    SetBackColorToShadeOfLastColor( 0x10 );

    TMaterialAttributeHeader Header;
    Assert( Header.Type == EMaterialAttributeType_Type8 );

// POSSIBLE COMPAT ISSUE
// #ifndef CFB_GFS
//     f32 Field00;
//     u32 Field04;
// #else
    TVector3 Field00;
    f32 Field0C;
    f32 Field10;
    f32 Field14;
    f32 Field18;
    TVector3 Field1C;
    f32 Field28;
    f32 Field2C;
    s32 Field30;
    s32 Field34;
    s32 Field38;
    EMaterialAttributeType8Flags Flags;
//#endif

} TMaterialAttributeAlphaCrunch;

//
// -- End Material types --
//

//
// -- Model types --
//

typedef struct
{
    SetRandomBackColor();

    TChunkHeader Header;
    EModelFlags Flags;

    if ( Flags & EModelFlags_Skin )
    {
        SetBackColorToShadeOfLastColor(0x20);
        u32 BoneCount;
        TMatrix4x4 InverseBindMatrices[BoneCount];

        SetBackColorToShadeOfLastColor(0x20);
        u16 BoneToNodeIndices[BoneCount];
        if ( Header.Version >= 0x2040001) {
            u8 Unk0;
        }
    }

    if ( Flags & EModelFlags_BoundingBox )
    {
        SetBackColorToShadeOfLastColor(0x20);
        TExtents3D BoundingBox;
    }

    if ( Flags & EModelFlags_BoundingSphere )
    {
        SetBackColorToShadeOfLastColor(0x20);
        TSphere3D BoundingSphere;
    }

    struct TNode RootNode( Header.Version );
} TModel <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();

    THashString Name( version );
    TVector3 Translation;
    TQuaternion Rotation;
    TVector3 Scale;

    if ( version <= 0x1090000 )
    {
        u8 Unknown1;
    }

    u32 AttachmentCount;
    if ( AttachmentCount > 0 )
        struct TNodeAttachment Attachments( version )[AttachmentCount];

    if ( version > 0x1060000 )
    {
        bool HasProperties;
        if ( HasProperties )
        {
            TUserPropertyDictionary Properties( version );
        }
    }

    if ( version > 0x1104230 )
    {
        f32 FieldE0;
    }

    u32 ChildCount;
    if ( ChildCount > 0 )
        struct TNode Children( version )[ChildCount];

} TNode <optimize=false, read=TNodeToString>;

string TNodeToString( TNode& value )
{
    string buffer;
    SPrintf( buffer, "%s", THashStringToString( value.Name ) );
    return buffer;
}

typedef struct( u32 version )
{
    SetRandomBackColor();
    ENodeAttachmentType Type;

    switch ( Type )
    {
        case ENodeAttachmentType_Mesh: struct TModelPack Value; break;
        case ENodeAttachmentType_Node: struct TNode Value; break;
        case ENodeAttachmentType_Geometry: struct TMesh Value( version ); break;
        case ENodeAttachmentType_Camera: struct TCamera Value( version ); break;
        case ENodeAttachmentType_Light: struct TLight Value( version ); break;
        case ENodeAttachmentType_Epl: struct TEpl Value( version ); break;
        case ENodeAttachmentType_EplLeaf: struct TEplLeaf Value( version ); break;
        case ENodeAttachmentType_Morph: struct TMorph Value( version ); break;
        default: Assert( false, "Unknown node attachment type" );
    }
} TNodeAttachment <optimize=false>;


typedef struct
{
    u16 A, B, C;
} TTriangle16;

typedef struct
{
    u32 A, B, C;
} TTriangle32;

typedef struct(u32 version)
{
    EMeshFlags Flags;
    EVertexAttributeFlags VertexAttributeFlags;

    if ( Flags & EMeshFlags_Triangles )
    {
        u32 TriangleCount;
        ETriangleIndexFormat TriangleIndexFormat;
    }

    u32 VertexCount;

    if ( version >= 0x2110205 ) {
        u8 TriangleStrideType;
    }

    if ( version > 0x1103020 )
    {
        u32 InvisibleShadowCaster;
    }
    
    if ( version >= 0x2000000 ) {
        struct TVertexMetaphor Vertices(Flags,VertexAttributeFlags,version)[VertexCount];
    } else {
        struct TVertex Vertices( Flags, VertexAttributeFlags )[VertexCount];
    }
    
    if (Flags & EMeshFlags_Skin && version >= 0x2110213) {
        u8 Unk1;
    }

    if ( Flags & EMeshFlags_MorphTargets )
    {
        struct TMorphTargetList MorphTargets;
    }

    if ( Flags & EMeshFlags_Triangles )
    {
        switch ( TriangleIndexFormat )
        {
            case ETriangleIndexFormat_UInt16: TTriangle16 Triangles[TriangleCount]; break;
            case ETriangleIndexFormat_UInt32: TTriangle32 Triangles[TriangleCount]; break;
            default: Assert( false, "Unknown triangle index format" );
        }
    }

    if ( Flags & EMeshFlags_Material )
    {
        THashString MaterialName( version );
    }

    if ( Flags & EMeshFlags_BoundingBox )
    {
        TExtents3D BoundingBox;
    }

    if ( Flags & EMeshFlags_BoundingSphere )
    {
        TSphere3D BoundingSphere;
    }

    if ( Flags & EMeshFlags_Lod )
    {
        f32 FieldD4;
        f32 FieldD8;
    }
} TMesh <optimize=false>;

typedef struct( EMeshFlags meshFlags, EVertexAttributeFlags vertexAttributeFlags, u32 version )
{
    if ( vertexAttributeFlags & EVertexAttributeFlags_PositionXYZ )  TVector3 Position;
    if ( vertexAttributeFlags & EVertexAttributeFlags_PositionXYZW ) TVector4 Position;
    if ( vertexAttributeFlags & EVertexAttributeFlags_TexCoord0 ) {
        f16 TexCoord0X;
        f16 TexCoord0Y;  
    }
    if ( vertexAttributeFlags & EVertexAttributeFlags_TexCoord1 ) {
        if ( vertexAttributeFlags & 0x1000 ) {
            f16 TexCoord1X;
            f16 TexCoord1Y;
        } else {
            u16 TexCoord1X;
            u16 TexCoord1Y;
        }    
    }
    if ( vertexAttributeFlags & EVertexAttributeFlags_TexCoord2 ) {
        if ( vertexAttributeFlags & 0x2000 ) {
            f16 TexCoord2X;
            f16 TexCoord2Y;
        } else {
            u16 TexCoord2X;
            u16 TexCoord2Y;
        }    
    }
    if ( vertexAttributeFlags & EVertexAttributeFlags_Normal )          TVector3 Normal;
    if ( vertexAttributeFlags & EVertexAttributeFlags_Tangent )         TVector3 Tangent;
    if ( vertexAttributeFlags & EVertexAttributeFlags_Binormal )        TVector3 Binormal;
    if ( vertexAttributeFlags & EVertexAttributeFlags_DiffuseColor )    u32 DiffuseColor;
    if ( vertexAttributeFlags & EVertexAttributeFlags_Color2 )          u32 Color2;
    if ( vertexAttributeFlags & EVertexAttributeFlags_Color3 )          u32 Color3;
    if ( meshFlags & EMeshFlags_Skin )
    {
        if (version < 0x2040001) {
            struct
            {
                f32 Weights[4];
                u8 Indices[4];
            } VertexWeights;
        } else {
            struct {
                u16 Weights[8];
                u16 Indices[8];
            } VertexWeightsMetaphor;
        }
    }
} TVertexMetaphor <optimize=false>;

typedef struct( EMeshFlags meshFlags, EVertexAttributeFlags vertexAttributeFlags )
{
    if ( vertexAttributeFlags & EVertexAttributeFlags_PositionXYZ )  TVector3 Position;
    if ( vertexAttributeFlags & EVertexAttributeFlags_PositionXYZW ) TVector4 PositionXYZW;
    if ( vertexAttributeFlags & EVertexAttributeFlags_Normal )       TVector3 Normal;
    if ( vertexAttributeFlags & EVertexAttributeFlags_Tangent )      TVector3 Tangent; // maybe swapped?
    if ( vertexAttributeFlags & EVertexAttributeFlags_Binormal )     TVector3 Binormal;
    if ( vertexAttributeFlags & EVertexAttributeFlags_DiffuseColor ) u32 DiffuseColor;
    if ( vertexAttributeFlags & EVertexAttributeFlags_TexCoord0 )    TVector2 TexCoord0;
    if ( vertexAttributeFlags & EVertexAttributeFlags_TexCoord1 )    TVector2 TexCoord1;
    if ( vertexAttributeFlags & EVertexAttributeFlags_TexCoord2 )    TVector2 TexCoord2;
    if ( vertexAttributeFlags & EVertexAttributeFlags_Color3 )       u32 Color3;

    if ( meshFlags & EMeshFlags_Skin )
    {
        struct
        {
            f32 Weights[4];
            u8 Indices[4];
        } VertexWeights;
    }
} TVertex <optimize=true>;

typedef struct
{
    u32 Flags;
    u32 Count;
    struct TMorphTarget MorphTargets[Count];
} TMorphTargetList <optimize=false>;

typedef struct
{
    u32 Flags;
    u32 VertexCount;
    TVector3 Vertices[VertexCount];
} TMorphTarget <optimize=false>;

typedef struct ( u32 version )
{
    TMatrix4x4 ViewMatrix;
    f32 ClipPlaneNear;
    f32 ClipPlaneFar;
    f32 FieldOfView;
    f32 AspectRatio;
    if ( version > 0x1104060 )
    {
        f32 Field190;
    }
    if ( version >= 0x2110050 ) {
        u8 Field198;
        f32 Field19C;
        f32 Field1A0;
    }
} TCamera;

typedef struct( u32 version )
{
    if ( version > 0x1104190 )
    {
        ELightFlags Flags;
    }

    ELightType Type;
    TVector4 AmbientColor;
    TVector4 DiffuseColor;
    TVector4 SpecularColor;

    switch ( Type )
    {
        case ELightType_Type1: // Directional
            f32 Field20; // 0
            f32 Field04; // 0
            f32 Field08; // 1
            break;

        case ELightType_Spot:
            f32 Field20; // 0
            f32 Field04; // 0
            f32 Field08; // 1
            f32 AngleInnerCone; // 0.08377809
            f32 AngleOuterCone; // 0.245575309
            // fallthrough

        case ELightType_Point:
            f32 Field10; // 0
            f32 Field04; // 0
            f32 Field08; // 0

            if ( Flags & ELightFlags_Bit2 )
            {
                f32 AttenuationStart; // attenuation start?
                f32 AttenuationEnd; // attenuation end?
            }
            else
            {
                f32 Field60; // 0
                f32 Field64; // 0
                f32 Field68; // 0
            }
            break;
    }
} TLight;

typedef struct( u32 version )
{
    u32 MorphTargetCount;
    u32 TargetInts[MorphTargetCount];
    THashString NodeName( version );
} TMorph;

//
// -- End Model type
//

//
// -- Animation types
//

typedef struct
{
    SetRandomBackColor();

    TChunkHeader Header;

    if ( Header.Version > 0x1104950 )
    {
        EAnimationPackFlags Flags;
    }

    u32 AnimationCount;
    if ( AnimationCount > 0 )
        struct TAnimation Animations( Header.Version )[ AnimationCount ];

    u32 BlendAnimationCount;
    if ( BlendAnimationCount > 0 )
        struct TAnimation BlendAnimation( Header.Version )[ BlendAnimationCount ];
    if ( Header.Version > 0x1104950 )
    {
        if ( Flags & EAnimationPackFlags_Flag4 )
        {
            struct TAnimationExtraData ExtraData( Header.Version );
        }
    }
    if ( Header.Version > 0x2109900 ) 
    {
        u32 AnimArray3Count;
        if ( AnimArray3Count > 0 )
            struct TAnimation AnimArray3( Header.Version )[ AnimArray3Count ];   
    }
} TAnimationPack <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();

    if ( version > 0x1104110 )
    {
        EAnimationFlags Flags;
    }

    f32 Duration;
    u32 ControllerCount;
    if ( version > 0x01105100 || CFBHack )
    {
        s32 Unknown1;
        s32 Unknown2;
        // Fails in CFB blend animation (c02_03_36030.GAP)
        // Has 2 layers, maybe sum of layers?
        // Assert( Unknown1 == ControllerCount );
    }

    if ( ControllerCount )
    {
        struct( u32 version )
        {
            struct TAnimationController Controllers( version )[ ControllerCount ];
        } Controllers( version );
    }

    if ( Flags & EAnimationFlags_Flag10000000 )
        struct TAnimationFlagsFlag10000000Data Flag10000000Data( version );

    if ( Flags & EAnimationFlags_Flag20000000 )
        struct TAnimationExtraData ExtraAnimData( version );

    if ( Flags & EAnimationFlags_Flag80000000 )
        struct TAnimationFlag80000000Data Field1C( version );

    if ( Flags & EAnimationFlags_HasBoundingBox )
        struct TExtents3D BoundingBox;

    if ( Flags & EAnimationFlags_HasSpeed )
        f32 Speed;

    if ( Flags & EAnimationFlags_HasProperties )
        struct TUserPropertyDictionary Properties( version );
} TAnimation <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();

    u32 Count;
    struct( u32 version )
    {
        struct TEpl Epl( version );
        THashString Field04( version );
    } Entries( version )[ Count ] <optimize=false>;
} TAnimationFlagsFlag10000000Data <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();

    u32 Field00;
    THashString Field04( version );
    struct TAnimationLayer Field20( version );
} TAnimationFlag80000000Data <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();

    struct TAnimation Field00( version );
    f32 Field10;
    struct TAnimation Field04( version );
    f32 Field14;
    struct TAnimation Field08( version );
    f32 Field18;
    struct TAnimation Field0C( version );
    f32 Field1C;
} TAnimationExtraData <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();

    ETargetKind TargetKind;
    s32 TargetId<format=hex>;
    THashStringGap TargetName( version );
    u32 LayerCount;
    struct TAnimationLayer Layers( version )[ LayerCount ];
} TAnimationController <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();

    EKeyType KeyType;
    u32 KeyCount;

    if ( KeyCount > 0 )
    {
        f32 KeyTimings[ KeyCount ];

        switch ( KeyType )
        {
            case EKeyType_NodePR: struct TNodePRKey Keys[ KeyCount ]; break;
            case EKeyType_NodePRS: struct TNodePRSKey Keys[ KeyCount ]; break;

            case EKeyType_NodePRHalf_2:
            case EKeyType_NodePRHalf:
                struct TNodePRHalf Keys[ KeyCount ];
                break;

            case EKeyType_NodePRSHalf: struct TNodePRSHalf Keys[ KeyCount ]; break;
            case EKeyType_NodeRHalf: struct TNodeRHalf Keys[ KeyCount ]; break;
            case EKeyType_NodeSHalf: struct TNodeSHalf Keys[ KeyCount ]; break;

            case EKeyType_Vector3:
            case EKeyType_Vector3_2:
            case EKeyType_Vector3_3:
            case EKeyType_Vector3_4:
            case EKeyType_MaterialVector3_5:
                struct TVector3Key Keys[ KeyCount ];
                break;

            case EKeyType_Quaternion:
            case EKeyType_Quaternion_2:
                struct TQuaternionKey Keys[ KeyCount ];
                break;

            case EKeyType_Single:
            case EKeyType_Single_2:
            case EKeyType_Single_3:
            case EKeyType_MaterialSingle_4:
            case EKeyType_Single_5:
            case EKeyType_Single_6:
            case EKeyType_CameraFieldOfView:
            case EKeyType_Single_8:
            case EKeyType_SingleAlt_2:
            case EKeyType_MaterialSingle_9:
            case EKeyType_SingleAlt_3:
                struct TSingleKey Keys[ KeyCount ];
                break;

            case EKeyType_Single5:
            case EKeyType_Single5_2:
            case EKeyType_Single5Alt:
            case EKeyType_36P5R:
                struct TSingle5Key Keys[ KeyCount ];
                break;

            case EKeyType_PRSByte: struct TPRSByteKey Keys[ KeyCount ]; break;
            case EKeyType_Single3Byte: struct TSingle3ByteKey Keys[ KeyCount ]; break;
            case EKeyType_SingleByte: struct TSingleByteKey Keys[ KeyCount ]; break;
            case EKeyType_Type22: struct TKeyType22 Keys[ KeyCount ]; break;

            case EKeyType_Type31:
                {
                    if ( version > 0x01105100 || CFBHack )
                    {
                        struct TKeyType31FullBody Keys[ KeyCount ];
                    }
                    else
                    {
                        struct TKeyType31Dancing Keys[ KeyCount ];
                    }
                }
                break;

			// P5R keys
			case 34: struct TKeyType34P5R Keys [ KeyCount ]; break;

			case 35: struct TKeyType35P5R Keys [ KeyCount ]; break;

            default:
			    local string buffer;
                SPrintf( buffer, "Unknown/Invalid Key frame type %01d", KeyType );
                Assert( false, buffer );
        }

         // Read scale values for compressed keys
        if ( KeyType == EKeyType_NodePRHalf   || KeyType == EKeyType_NodePRSHalf ||
             KeyType == EKeyType_NodePRHalf_2 || KeyType == EKeyType_Type31 ||
             KeyType == EKeyType_NodeRHalf    || KeyType == EKeyType_NodeSHalf ||
			 KeyType == EKeyType_34P5R        || KeyType == EKeyType_35P5R      )
        {
            TVector3 PositionScale;
            if ( ( version <= 0x01105100 || CFBHack ) && KeyType != EKeyType_Type31 )
                TVector3 ScaleScale;
        }
    }
} TAnimationLayer <optimize=false>;

typedef struct
{
    TVector3 Position;
    TQuaternion Rotation;
} TNodePRKey;

typedef struct
{
    TVector3 Position;
    TQuaternion Rotation;
    TVector3 Scale;
} TNodePRSKey;

typedef struct
{
    TVector3 Position;
    TQuaternion Rotation;
    TVector3 Scale;
    u8 Byte;
} TPRSByteKey;

typedef struct
{
    TVector3Half Position;
    TQuaternionHalf Rotation;
} TNodePRHalf;

typedef struct
{
    TVector3Half Position;
    TQuaternionHalf Rotation;
    TVector3Half Scale;
} TNodePRSHalf;

typedef struct
{
    TQuaternionHalf Rotation;
} TNodeRHalf;

typedef struct
{
    TVector3Half Scale;
} TNodeSHalf;

typedef struct { TVector3 Value; } TVector3Key;
typedef struct { TQuaternion Value; } TQuaternionKey;
typedef struct { f32 Value; } TSingleKey;
typedef struct { f32 Field00; u8 Field04; } TSingleByteKey;

typedef struct
{
    f32 Field04;
    f32 Field08;
    f32 Field0C;
    u8 Field00;
} TSingle3ByteKey;

typedef struct
{
    s32 Field04;
    s32 Field08;
    s16 Field0C;
    f32 Field10;
    f32 Field14;
    f32 Field18;
    s32 Field1C;
    s16 Field20;
    f32 Field24;
    f32 Field28;
    f32 Field2C;
    u8 Field00;
} TKeyType22;

typedef struct
{
    TVector3Half Position;
} TKeyType31Dancing;

typedef struct
{
    TVector3Half Position;
	TVector3Half Scale;
} TKeyType34P5R;

typedef struct
{
    TQuaternionHalf Rotation;
    TVector3Half Scale;
} TKeyType35P5R;

typedef struct
{
    u8 Data[ 0x1C ];
} TKeyType31FullBody;

typedef struct { 

    f32 XOffset; 
    f32 YOffset;
    f32 XScale;
    f32 YScale;
    f32 UVRotation;
} TSingle5Key;

//
// -- End Animation types
//


//
// -- Epl types
//

typedef struct( u32 version )
{
    SetRandomBackColor();

    EEplFlags Flags;
    TNode RootNode( version );
    struct TEplAnimation Animation( version );

    if ( version > 0x1105060 )
    {
        u16 Field40;
    }

    //Assert(false, "Not implemented");
} TEpl  <optimize=false>;

local u32 keyCountsBuffer[1024];
typedef struct( u32 version )
{
    SetRandomBackColor();

    u32 Field00;
    f32 Field04;
    TAnimation Animation( version );
    u32 ControllerCount;

    local u32 i;
    local u32 controllerCount = Animation.ControllerCount;

    struct TEplAnimationController Controllers( version, keyCountsBuffer )[ ControllerCount ];
} TEplAnimation  <optimize=false>;

typedef struct( u32 version, u32 keyCounts[] )
{
    SetRandomBackColor();

    f32 Field00;
    f32 Duration;
    s32 ControllerIndex; // 0x08

    if ( ControllerIndex != -1 )
    {
        //local u32 keyCount = Animation.Controller[ControllerIndex].KeyCount;
        local u32 keyCount = keyCounts[ControllerIndex];

        if ( keyCount != 0 )
        {
            struct TEplAnimationKey Keys[keyCount];
        }
    }

    s32 Field0C;
} TEplAnimationController <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();
    if ( version > 0x2110060 )
    {
        TVector2 Field34;
        TVector2 Field3C;
    }
    EEplLeafFlags Flags; // 0x2C
    THashString Name( version ); // 0x30
    local u32 type = ReadInt( FTell() + 0 );

    // 0x40
    switch ( type )
    {
        case 0:  struct TEplDummy Data( version );                break;
        case 1:  struct TEplParticle Data( version );             break;
        case 2:  struct TEplFlashPolygon Data( version );         break;
        case 3:  struct TEplCirclePolygon Data( version );        break;
        case 4:  struct TEplLightningPolygon Data( version );     break;
        case 5:  struct TEplTrajectoryPolygon Data( version );    break;
        case 6:  struct TEplWindPolygon Data( version );          break;
        case 7:  struct TEplModel Data( version );                break;
        case 8:  struct TEplTrajectoryPolygon Data( version );    break; 
        case 9:  struct TEplBoardPolygon Data( version );         break;
        case 10: struct TEplObjectParticles Data( version );      break;
        case 11: struct TEplGlitterPolygon Data( version );       break;
        case 12: struct TEplGlitterPolygon Data( version );       break;
        case 13: struct TEplDirectionalParticles Data( version ); break;
        case 14: struct TEplCamera Data( version );               break;
        case 15: struct TEplLight Data( version );                break;
        case 16: struct TEplPostEffect Data( version );           break;
        case 17: struct TEplHelper Data( version );               break;
        default: Assert(false, "Not implemented"); break;
    }
} TEplLeaf  <optimize=false>;

typedef struct
{
    u32 Type;
    u32 Field04;
} TEplLeafDataHeader <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();
    THashString FileName( version );
    if ( version < 0x2000002) {
        u32 FileEmbedType; // 1 - get a file embedded in the exe (e.g <Smoke00>)
    } else {
        u16 FileEmbedType;
        u16 Field0;        
    }

    if ( FileEmbedType == 2 )
    {
        u32 FileType; // filetype vtable - 0x14226adf0, P5R.exe v1.01
        u32 DataLength;
        //u8 Data[ DataLength ];

        switch ( FileType )
        {
            case 0: break;
            case 1: u8 TextureData[ DataLength ]; break; // texture
            case 2: struct TModelPackFile GfsMesh; break; // GFS mesh, untested
            case 3: struct TEplFile EplEffect; break; // EPL effect
            case 4: struct TEptFile EplTexture; break; // EPL texture (EPT)
            case 5: struct TModelPackFile GmdModel; break; // GMD model, untested
            case 6: struct TEpdFile EplDisplacement; break; // EPL displacement
            default: Assert( false );
        }
    }
} TEplEmbeddedFile <optimize=false>;

typedef struct( u32 version, u32 in_type )
{
    SetRandomBackColor();

    local u32 type = in_type;

    //u32 Field00 = Rotation
    //u32 Field04 = ParticleAmount

    u32 RandomSpawnDelay;
    f32 ParticleLife; 
    u32 AngleSeed; 
    f32 DespawnTimer; 
    TVector2 SpawnChoker;
    if ( version > 0x2107001 ) 
        TVector2 Field4C;
    if ( version > 0x2110193 ) 
        TVector2 Field54;
    f32 ColorOverLifeOffset; 
    u32 FieldC4; 
    TVector2 OpacityOverLife; 
    
    if ( version >= 0x1104041 )
        struct TEplLeafCommonData6 ColorOverLife_Bezier(version); 

    if ( version >= 0x1104701 )
        f32 FieldC0; 

    if ( version < 0x1104041 )
        struct TEplLeafCommonData5 FieldC8;
    else 
        struct TEplLeafCommonData6 SizeOverLife(version); 

    f32 Field12C; //Nothing
    f32 Field130;
    if ( version > 0x2107001 )
        TVector2 Field140;
    if ( version >= 0x1104041 ) { // 0x146f0f478
        TVector2 SpawnerAngles;
        TVector2 CycleRate_FromBirth;
    } else {
        struct TEplLeafCommonData5 SpawnAngleAndCycleRate;
    }
    f32 CycleRate_Global;
    u32 Field148;
    if ( version > 0x1104170 ) { // 0x146f0f53f
        u32 ParticleMultiplier;
        f32 Field150;
    }
    if ( version > 0x1104050 ) { // 0x146f0f582
        f32 ParticleScale;
        f32 ParticleSpeed;
    } 

    switch ( type )
    {
        case 0: break;
        case 1: struct TEplSmokeEffectParams Params( version ); break;
        case 2: struct TEplExplosionEffectParams Params( version ); break;
        case 3: struct TEplSpiralEffectParams Params( version ); break;
        case 4: struct TEplBallEffectParams Params( version ); break;
        case 5: struct TEplCircleEffectParams Params( version ); break;
        case 6: struct TEplStraightLineEffectParams Params( version ); break;
        default: Assert(false, "Not implemented"); break;
    }
} TEplParticleEmitter <optimize=false>;

typedef struct
{
    SetRandomBackColor();

    u16 Type;

    switch ( Type )
    {
        case 0:
        {
            s32 Field04;
            s32 Field0C;
            break;
        }

        case 1:
        {
            f32 Field04;
            f32 Field0C;
            break;
        }

        case 2:
        {
            u32 Field04;
            u32 Field0C;
            break;
        }

        case 3:
        {
            f32 Field04;
            f32 Field08;
            f32 Field0C;
            f32 Field10;
            break;
        }
    }

    TVector4 ValueKeyframes;
    u16 TimeShift[23]<read=Str("%d (%.4f)", this, (f32)this / (1 * 65535))>;
} TEplLeafCommonData5 <optimize=false>;

typedef struct(u32 version)
{
    SetRandomBackColor();

    u16 Type;

    switch ( Type )
    {
        case 0:
        {
            s32 Int1; // time less than 0.33 secs
            s32 Int2; // between 0 - 0.67 secs
            s32 Int3; // between 0.33 - 1 secs
            s32 Int4; // time more than 0.67 secs
            break;
        }

        case 1:
        {
            f32 Float1;
            f32 Float2;
            f32 Float3;
            f32 Float4;
            break;
        }

        case 2:
        {
            TColor8 Color1;
            TColor8 Color2;
            TColor8 Color3;
            TColor8 Color4;
            break;
        }

        case 3:
        {
            TVector2 Vec1;
            TVector2 Vec2;
            TVector2 Vec3;
            TVector2 Vec4;
            break;
        }
    }

    TVector4 ValueKeyframes;
    u16 TimeShift[23]<read=Str("%d (%.4f)", this, (f32)this / (1 * 65535))>;
    if (version > 0x2110186) {
        u16 Field62;
    }
} TEplLeafCommonData6 <optimize=false>;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;
} TEplDummy;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    // 0(r4)
    u32 Type; // particle emitter type

    if ( version < 0x1104170 )
        FSeek(4);

    if ( version > 0x1104180 )
    {
        u32 Field10;
    }

    // 0(r27)
    struct TEplParticleEmitter Emitter( version, Type );

    // 0x10(r27)
    struct TEplEmbeddedFile EmbeddedFile( version );

} TEplParticle <optimize=false>;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 RenderType;
    f32 AnimationLength;
    u32 RayCount;
    f32 Intensity;
    u32 LayerMode;
    u32 Seed;
    TVector2 RaySpawnSpeed;
    TVector2 FadeParams;
    struct TEplLeafCommonData5 RayDistanceParams;

    if ( version > 0x1104700 )
        f32 Field20;

    if ( version > 0x1104050 )
    {
        f32 Size;
        f32 Speed;
    }

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplFlashPolygonRadiation Polygon( version ); break;
        case 2: struct TEplFlashPolygonExplosion Polygon( version ); break;
        case 3: struct TEplFlashPolygonRing Polygon( version ); break;
        case 4: struct TEplFlashPolygonSplash Polygon( version ); break;
        case 5: struct TEplFlashPolygonCylinder Polygon( version ); break;
        default: Assert(false, "Not implemented"); break;
    }

    struct TEplEmbeddedFile EmbeddedFile( version );
} TEplFlashPolygon;

typedef struct( u32 version )
{
    u32 InnerColor;
    u32 OuterColor;
    TVector2 FlashWidthInner;
    TVector2 FlashWidthOuter;
    TVector2 FlashLength;
    TVector2 OrbitSpeed;
    f32 OrbitSpeedVelocity;
    u32 FieldB4;
} TEplFlashPolygonRadiation;

typedef struct( u32 version )
{
    TVector2 Radius;
    u32 InnerColor;
    u32 OuterColor;
    TVector2 FlashWidth;
    TVector2 FlashLength;
    TVector2 ExplodeSpeed;
    f32 ExplodeSpeedVelocity;
} TEplFlashPolygonExplosion;

typedef struct( u32 version )
{
    struct TEplLeafCommonData5 RingRadius;
    struct TEplLeafCommonData5 RotationSpeed;
    u32 InnerColor;
    u32 OuterColor;
    TVector2 FlashWidthInner;
    TVector2 FlashWidthOuter;
    TVector2 FlashLength;
    TVector2 OrbitSpeed;
    f32 OrbitSpeedVelocity;
    u32 Field15C;
} TEplFlashPolygonRing;

typedef struct( u32 version )
{
    struct TEplLeafCommonData5 RingRadius;
    struct TEplLeafCommonData5 RotationSpeed;
    u32 InnerColor;
    u32 OuterColor;
    TVector2 FlashWidthInner;
    TVector2 FlashWidthOuter;
    TVector2 FlashLength;
    TVector2 LiftSpeed;
    f32 LiftVelocity;
} TEplFlashPolygonSplash;

typedef struct( u32 version )
{
    struct TEplLeafCommonData5 CylinderRadius;

    if ( version <= 0x1104040 )
        struct TEplLeafCommonData5 ColorOverTime;
    else
        struct TEplLeafCommonData6 ColorOverTime(version);

    TVector2 FlashWidth;
    TVector2 FlashLength;
    TVector2 LiftSpeed;
    f32 LiftVelocity;
    TVector2 OrbitSpeed;
    f32 OrbitVelocity;
    u32 Field168;
} TEplFlashPolygonCylinder;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 RenderType;
    f32 AnimationLength;
    u32 Field10;
    u32 Field1C;
    u32 InstanceCount;
    TVector2 FadeParams;

    if ( version > 0x1104050 )
    {
        f32 Size;
        f32 Speed;
    }

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplCirclePolygonRing Polygon( version ); break;
        case 2: struct TEplCirclePolygonTrajectory Polygon( version ); break;
        case 3: struct TEplCirclePolygonFill Polygon( version ); break;
        case 4: struct TEplCirclePolygonHoop Polygon( version ); break;
        default: Assert(false, "Not implemented"); break;
    }

    // if (*(int*)(0xCE251C + ((Type * 0x1c) + 0x18)) !=  0x0) {
    if ( Type != 1 && Type != 3 && Type != 0 ) // Type != 0 is temp
        struct TEplEmbeddedFile EmbeddedFile( version );
} TEplCirclePolygon;

typedef struct( u32 version )
{
    f32 Field24;
    struct TEplLeafCommonData5 Field28;
    struct TEplLeafCommonData5 Field7C;
    TVector2 FieldD0;
    u32 FieldD8;
    u32 FieldDC;
    u32 FieldE0;
} TEplCirclePolygonRing;

typedef struct( u32 version )
{
    f32 Field24;
    f32 Field28;
    struct TEplLeafCommonData5 Field2C;
    struct TEplLeafCommonData5 Field90;
    f32 FieldF4;
    f32 FieldF8;
    f32 FieldFC;
    f32 Field100;
} TEplCirclePolygonTrajectory;

typedef struct( u32 version )
{
    f32 Field24;
    struct TEplLeafCommonData5 Field28;
    struct TEplLeafCommonData6 Field7C(version);
    struct TEplLeafCommonData6 FieldE0(version);
} TEplCirclePolygonFill;

typedef struct( u32 version )
{
    f32 Field28;
    f32 Field2C;
    f32 Field30;
    struct TEplLeafCommonData5 Field34;
    TVector2 Field88;
    struct TEplLeafCommonData6 Field90(version);
    struct TEplLeafCommonData6 FieldF4(version);
    struct TEplLeafCommonData6 Field158(version);
    f32 Field1BC;
    f32 Field1C0;
} TEplCirclePolygonHoop;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 BoltCount1;
    f32 PersistanceTime;
    u32 BoltCount2;
    u32 Field1C;
    u32 LightningPoints;
    f32 InnerGlowIntensity;
    f32 OuterGlowIntensity;
    u32 InnerColor;
    u32 OuteColor;
    u32 Field54;
    u32 Field60;
    TVector2 SpawnRate;
    TVector2 LightningWaveFrequency;
    TVector2 LightningWaveAmplitude;
    TVector2 LightningRandomAmplitude;
    f32 FadeInTime;
    f32 LightningSpeed;
    f32 SizeReduction;
    f32 Field40;

    if ( version > 0x1104050 )
    {
        f32 ModelSize;
        f32 AnimationSpeed;
    }

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplLightningPolygonRod Polygon( version ); break;
        case 2: struct TEplLightningPolygonBall Polygon( version ); break;
        default: Assert(false, "Not implemented"); break;
    }
} TEplLightningPolygon;

// verified
typedef struct( u32 version )
{
    f32 RodHeight;
    f32 RodHeightVariation;
} TEplLightningPolygonRod;

// verified
typedef struct( u32 version )
{
    struct TEplLeafCommonData5 BallRadius;
    TVector2 LightningLength;
    TVector2 OrbitSpeed;
    f32 FieldC8;
    u32 FieldCC;
    TVector2 ParticleRotate;
    f32 FieldD8;
    u32 FieldDC;
} TEplLightningPolygonBall;

typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;

    if ( version <= 0x1104170 )
        FSeek( 4 );

    u32 Field00;
    u32 Brightness;
    f32 FuzzAmount;
    f32 StartingSize;
    u32 TrailLife;
    f32 Field130;
    f32 Field134;

    if ( version > 0x1104170 )
        f32 Length;

    struct TEplLeafCommonData6 Field10;
    struct TEplLeafCommonData6 Field74;
    struct TEplLeafCommonData5 FieldD8;
    struct TEplParticleEmitter Field140(version, Type);
    bool HasEmbeddedFile;

    if ( HasEmbeddedFile )
        struct TEplEmbeddedFile EmbeddedFile( version );

} TEplTrajectoryPolygon;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 Field00;
    f32 Field04;
    u32 ParticleCount;
    f32 WindOpacity;
    u32 TextureDrawFlags;
    u32 WindPolyCount;
    u32 WindSeed;

    if ( version <= 0x1104040 )
        struct TEplLeafCommonData5 ColorOverLifeBezier;
    else
        struct TEplLeafCommonData6 ColorOverLifeBezier(version);

    TVector2 ParticleDensity;
    TVector2 Field90;
    TVector2 Field98;
    TVector2 Field7C;
    
    if ( version > 0x1104700 )
        f32 Field84;
       
    if ( version > 0x1104050 )
    {
        f32 WindSize;
        f32 WindSpeed;
    } 

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplWindPolygonSpiral Polygon( version ); break;
        case 2: struct TEplWindPolygonExplosion Polygon( version ); break;
        case 3: struct TEplWindPolygonBall Polygon( version ); break;
        default: Assert(false, "Not implemented"); break;
    }     

    struct TEplEmbeddedFile Field70( version );    
} TEplWindPolygon;

// verified
typedef struct( u32 version )
{
    //struct TEplLeafCommonData5 FieldAC;  
    u16 Type;
    f32 NearClip;
    f32 FarClip;
    f32 NearTarget;
    f32 FarTarget;
    TVector4 Field10;
    u8 Field24[46];

    //struct TEplLeafCommonData5 Field100;
    u16 Type;
    f32 YRandom_Min;
    f32 YRandom_Max;
    f32 YWind_Top;
    f32 YWind_Base;
    TVector4 Field11;
    u8 Field25[46];
    
    //struct TEplLeafCommonData5 Field154;
    u16 Type;
    f32 Phase1Height;
    f32 Phase2Height;
    f32 Phase3Height;
    f32 Phase4Height;
    TVector4 Field12;
    u8 Field26[46];

    TVector2 RingOnSpherePos;
    TVector2 ParticleOrbitSpeed;
    TVector2 RingRotateSpeed;
    f32 Field1C0;
    u32 Field1C4;
    TVector2 Field1C8;
} TEplWindPolygonSpiral;

// verified
typedef struct( u32 version )
{
    struct TEplLeafCommonData5 ExplosionRadius;
    TVector2 ExplodeSize;
    TVector2 OrbitSpeed;
    f32 Field110;
    f32 Field114;

    if ( version > 0x1104080 )
        TVector2 Field118;
} TEplWindPolygonExplosion;

// verified
typedef struct( u32 version )
{
    struct TEplLeafCommonData5 BallRadius;
    struct TEplLeafCommonData5 ParticleSize;
    TVector2 WindLength;
    TVector2 OrbitSpeed;
    f32 Field164;
    u32 Field168;
    TVector2 Field16C;
} TEplWindPolygonBall;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 Field00;

    if ( version > 0x1104050 )
    {
        f32 ModelSize;
        f32 AnimSpeed;
    }
    else
    {
        local f32 Field04 = 1.0f;
        local f32 Field08 = 1.0f;
    }

    if ( Field00 & 0x10000000 )
    {
        f32 Field0C;
        f32 Field10;
        f32 Field14;
        f32 Field18;
        f32 Field1C;
        f32 Field20;
        s32 Field24;
        f32 Field28;
        f32 Field2C;
    }

    if ( version > 0x2110031 ) {
        f32 Unk0;
        u32 Unk1;
        TVector2 Unk2;
        TVector2 Unk3;
        f32 Unk4;
        u32 Unk5;
    }

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplModel3DData Data( version ); break;
        case 2: struct TEplModel2DData Data( version ); break;
        default: Assert(false, "Not implemented"); break;
    }

    u8 HasEmbeddedFile;
    if ( HasEmbeddedFile )
        struct TEplEmbeddedFile EmbeddedFile( version );
} TEplModel;

// verified
typedef struct( u32 version )
{
} TEplModel3DData;

// verified
typedef struct( u32 version )
{
    f32 DistanceFromCamera;
} TEplModel2DData;

typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 RenderType;
    f32 AnimationLength;
    u32 LayerMode;
    u32 Seed;
    TVector2 FadeParams;
    f32 Size;
    f32 Speed;

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplSquareBoardPolygon Polygon( version ); break;
        case 2: struct TEplRectangleBoardPolygon Polygon( version ); break;
        default: Assert(false, "Not implemented"); break;
    }

    struct TEplEmbeddedFile EmbeddedFile( version );
} TEplBoardPolygon;

typedef struct( u32 version )
{
    struct TEplLeafCommonData6 SizeOverTime(version);
    struct TEplLeafCommonData6 ColorOverTime(version);
    TVector2 Rotation;
    f32 Opacity;
    f32 RotationVelocity;
    u32 Field108;

    if ( version > 0x1104280 )
    {
        TVector2 FieldF4;

        if ( version > 0x1104290 )
        {
            f32 Field20;
            f32 Field24;
        }
    }
} TEplSquareBoardPolygon;

typedef struct( u32 version )
{
    struct TEplLeafCommonData6 SizeXOverTime(version);
    struct TEplLeafCommonData6 SizeYOverTime(version);
    struct TEplLeafCommonData6 ColorOverTime(version);
    TVector2 Rotation;
    f32 Opacity;
    f32 RotationVelocity;
    u32 Field158;
    TVector2 Field16C;
    f32 OffsetX;
    f32 OffsetY;
} TEplRectangleBoardPolygon;

typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 Field00;
    u32 ParticleCount;
    f32 Field08;
    f32 Field0C;
    f32 Field10;

    struct TEplParticleEmitter EffectGenerator( version, Type );
    struct TEplEmbeddedFile EmbeddedFile( version );

    //Assert(false, "Not implemented");
} TEplObjectParticles <optimize=false>;

typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 Field00;
    f32 Field04;
    u32 Field08;
    u32 Field20;
    u32 Field150;
    TVector2 Field08;
    TVector2 Field14;
    struct TEplLeafCommonData5 FieldEC;
    f32 Field1C;
    struct TEplLeafCommonData6 Field24(version);
    struct TEplLeafCommonData6 Field88(version);
    f32 Field140;
    f32 Field144;
    f32 Field148;
    f32 Field14C;

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplGlitterPolygonExplosion Polygon( version ); break;
        case 2: struct TEplGlitterPolygonSplash Polygon( version ); break;
        case 3: struct TEplGlitterPolygonCylinder Polygon( version ); break;
        case 4: struct TEplGlitterPolygonWall Polygon( version ); break;
        default: Assert(false, "Not implemented"); break;
    }

    bool Field70; // r30
    if ( Field70 )
    {
        struct TEplEmbeddedFile EmbeddedFile( version );
    }
} TEplGlitterPolygon;

typedef struct( u32 version )
{
    TVector2 Field154;
    TVector2 Field15C;
    TVector2 Field164;
    TVector2 Field16C;
    f32 Field174;
} TEplGlitterPolygonExplosion;

typedef struct( u32 version )
{
    struct TEplLeafCommonData5 Field154;
    struct TEplLeafCommonData5 Field1A8;
    TVector2 Field1FC;
    TVector2 Field204;
    TVector2 Field20C;
    f32 Field214;
} TEplGlitterPolygonSplash;

typedef struct( u32 version )
{
    struct TEplLeafCommonData5 Field154;
    TVector2 Field1A8;
    TVector2 Field1B0;
    TVector2 Field1B8;
    f32 Field1C0;
    TVector2 Field1C4;
    f32 Field1CC;
    u32 Field1D0;
} TEplGlitterPolygonCylinder;

typedef struct( u32 version )
{
    struct TEplLeafCommonData5 Field154;
    TVector2 Field1A8;
    TVector2 Field1B0;
    TVector2 Field1B8;
    f32 Field1C0;
} TEplGlitterPolygonWall;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;

    if ( version > 0x1104180 )
    {
        u32 Field00;
    }

    struct TEplParticleEmitter ParticleEmittter(version, Type);
    struct TEplEmbeddedFile EmbeddedFile(version);
} TEplDirectionalParticles;

typedef struct( u32 version )
{
    SetRandomBackColor();

    f32 GlobalDisperseDistance;
    TVector2 SlideUpSpeed;
    TVector2 SlideDownSpeed;
    TVector2 DisperseStartDistance;
    TVector2 DisperseEndDistance;
    TVector2 DisperseRotation;
} TEplSmokeEffectParams;

typedef struct( u32 version )
{
    SetRandomBackColor();

    TVector2 DistanceTravelled;
    TVector2 LaunchSpeed;
    TVector2 ExplodeRotation;
    TVector2 ExpolodePitch;
    TVector2 GravityStrength;
    f32 ParticleSpeed;
} TEplExplosionEffectParams;

typedef struct( u32 version )
{
    SetRandomBackColor();

    f32 SpiralHeight;
    TVector2 SpiralStartRadius;
    TVector2 SpiralEndRadius;
    TVector2 SoftSpiralRotation;
    f32 HardSprialRotation;
    TVector2 SlideUpSpeed;
    TVector2 SlideDownSpeed;
} TEplSpiralEffectParams;

typedef struct( u32 version )
{
    SetRandomBackColor();

    TVector2 RadiusStart;
    TVector2 RadiusEnd;
    TVector2 OrbitSpeed;
    f32 OrbitSpeedMultiplier;
    TVector2 GravityStrength;
} TEplBallEffectParams;

typedef struct( u32 version )
{
    SetRandomBackColor();

    TVector2 CircleRadius;
    TVector2 RingExpand;
    f32 RingContract;
    TVector2 OrbitSpeed;
    f32 OrbitSpeedMultiplier;
    TVector2 RingPositionOnSphere;
    TVector2 LiftSpeed;
} TEplCircleEffectParams;

typedef struct( u32 version )
{
    SetRandomBackColor();

    f32 LineLength;
    TVector2 LiftSpeed;
    TVector2 GravityStrength;
    TVector2 DisperseInward;
    TVector2 DisperseOutward;
    TVector2 OscillateSpeed;
} TEplStraightLineEffectParams;

typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 Field00;
    f32 Field04;
    f32 Field08;
    u32 Field0C;

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplCameraMeshParams Params( version ); break;
        case 2: struct TEplCameraQuakeParams Params( version ); break;
        default: Assert(false, "Not implemented"); break;
    }

    bool HasEmbeddedFile; // 84(r30)
    if ( HasEmbeddedFile )
        TEplEmbeddedFile EmbeddedFile( version );
} TEplCamera;

typedef struct( u32 version )
{
    // empty
} TEplCameraMeshParams;

typedef struct( u32 version )
{
    f32 Field10;
    f32 Field14;
    f32 Field18;
    f32 Field1C;
    f32 Field20;
} TEplCameraQuakeParams;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 Field00;
    f32 Field04;
    f32 Field08;

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplLightMeshData Data( version ); break;
        case 2: struct TEplLightSceneData Data( version ); break;
        default: Assert(false, "Not implemented"); break;
    }

    bool HasEmbeddedFile; // 84(r30)
    if ( HasEmbeddedFile )
        TEplEmbeddedFile EmbeddedFile( version );
} TEplLight;

// verified
typedef struct( u32 version )
{
    // empty
} TEplLightMeshData;

// verified
typedef struct( u32 version )
{
    f32 Field0C;
    TVector2 Field10;
    u32 Field18;
    u32 Field1C;
    u32 Field20;

    if ( version > 0x1104910 )
    {
        f32 Field24;
        f32 Field28;
        f32 Field2C;
    }
} TEplLightSceneData;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 Field00;
    f32 Field04;

    switch ( Type )
    {
        case 0: break;
        case 1: struct TEplPostEffectRadiationBlurData Data( version ); break;
        case 2: struct TEplPostEffectStraightBlurData Data( version ); break;
        case 3: struct TEplPostEffectNoiseBlurData Data( version ); break;
        case 4: struct TEplPostEffectDistortionBlurData Data( version ); break;
        case 5: struct TEplPostEffectFillData Data( version ); break;
        case 6: struct TEplPostEffectLensFlareData Data( version ); break;
        case 7: struct TEplPostEffectColorCorrectionData Data( version ); break;
        case 8: struct TEplPostEffectMonotoneData Data( version ); break;

        case 9: struct TEplPostEffectLensFlareMake Data( version ); break;
        case 10: struct TEplPostEffectMotionBlur Data( version ); break;
        case 11: struct TEplPostEffectAfterimageBlur Data( version ); break;
        default: Assert(false, "Not implemented"); break;
    }

    bool HasEmbeddedFile; // 4C(r30)
    if ( HasEmbeddedFile )
        TEplEmbeddedFile EmbeddedFile( version );
} TEplPostEffect;

// verified
typedef struct( u32 version )
{
    TEplLeafCommonData6 Color(version);
    u32 Field74;
    TEplLeafCommonData6 BlurParams0(version);
    f32 blurParams1;
    f32 FieldE0;
    f32 FieldE4;

    if ( version > 0x1104930 )
    {
        u8 FieldE8;
    }
} TEplPostEffectRadiationBlurData;

// verified
typedef struct( u32 version )
{
    TEplLeafCommonData6 Field10(version);
    u32 Field74;
    TEplLeafCommonData6 Field78(version);
    f32 FieldDC;
} TEplPostEffectStraightBlurData;

// verified
typedef struct( u32 version )
{
    TEplLeafCommonData6 Field10(version);
    u32 Field74;
    TEplLeafCommonData6 Field78(version);
    TEplLeafCommonData6 FieldDC(version);

    if ( version > 0x1104920 )
    {
        u8 Field140;
    }
} TEplPostEffectNoiseBlurData;

// verified
typedef struct( u32 version )
{
    TEplLeafCommonData6 AlphaOverTime(version);
    u32 LayerMode;
    TEplLeafCommonData6 DistortAmountA(version);
    TEplLeafCommonData6 DistortAmountB(version);
    f32 DistortSpeedAX;
    f32 DistortSpeedAY;
    f32 DistortSpeedBX;
    f32 DistortSpeedBY;
} TEplPostEffectDistortionBlurData;

// verified
typedef struct( u32 version )
{
    TEplLeafCommonData6 Field10(version);
    TEplLeafCommonData6 Field74(version);
    TEplLeafCommonData6 FieldD8(version);
    TEplLeafCommonData6 Field13C(version);
    u32 FieldlA0;
} TEplPostEffectFillData;

// verified
typedef struct( u32 version )
{
    u32 Field10;
    u32 Field14;
    u32 Field18;
    TEplLeafCommonData6 Field1C(version);
    f32 Field80;
} TEplPostEffectLensFlareData;

// verified
typedef struct( u32 version )
{
    f32 CyanRed;
    f32 MagentaGreen;
    f32 YellowBlue;
    f32 Exposure;
    f32 Contrast;
    f32 Opacity;
    TVector2 FadeTimes;
} TEplPostEffectColorCorrectionData;

// verified
typedef struct( u32 version )
{
    f32 Opacity;
    TVector2 FadeTimes;
} TEplPostEffectMonotoneData;

// verified
typedef struct( u32 version )
{
    u32 Field10;
    u32 Field20;
    TEplLeafCommonData6 FieldA0(version);
    f32 Field60;
    f32 Field64;
    f32 Field68;
    f32 Field6C;
    f32 Field70;
    f32 Field74;
    f32 Field78;
    f32 Field7C;
    f32 Field80;
    f32 Field84;
    f32 Field88;
    f32 Field8C;
    f32 Field90;
    f32 Field94;
    f32 Field98;
    f32 Field9C;
} TEplPostEffectLensFlareMake;

// verified
typedef struct( u32 version )
{
    TEplLeafCommonData6 Field10(version);
    u32 Field74;
    TEplLeafCommonData6 Field78(version);
    f32 FieldDC;
    f32 FieldE0;
} TEplPostEffectMotionBlur;

// verified
typedef struct( u32 version )
{
    TEplLeafCommonData6 Field10(version);
    u32 Field74;
    TEplLeafCommonData6 Field78(version);
    f32 FieldDC;
} TEplPostEffectAfterimageBlur;

// verified
typedef struct( u32 version )
{
    SetRandomBackColor();
    TEplLeafDataHeader Header;

    u32 Type;
    u32 Field00;
    f32 Field04;
    f32 Field08;
    f32 Field0C;
    bool Field84; // r30
    if ( Field84 )
        TEplEmbeddedFile EmbeddedFile1( version );

    bool Field88; // r30
    if ( Field88 )
        TEplEmbeddedFile EmbeddedFile2( version );
} TEplHelper;

//
// -- End Epl types
//

//
// -- Model pack types --
//

//
// == Physics Data Chunk type stuff --
//
typedef struct
{
	u32 Field140;
	f32 Field13C;
	f32 Field138;
	f32 Field134;
	f32 Field130;
	u32 Entry1Count<name="Bone Dictionary Count">;
	u32 Entry2Count<name="Collision Capsule Count">;
	u32 Entry3Count<name="Bone Collection Count">;
} TChunkTypePhysicsDictionaryHeader <name="PhysicsDictionaryHeader">;

typedef struct( u32 version )
{
	f32 MotionScale;
	f32 Field38;
    if (version > 0x1104121) {
        f32 Field3C;
	    f32 SpringRate;
    }
	TBool8 hasName;
	if (hasName > 0)
	{
		THashString Name( version );
	}
	else{
		f32 Field18;
		f32 Field14;
		f32 Field10;
	}

}TEntryType1<name = "Bone Dictionary">;

typedef struct( u32 version )
{
	u16 CapsuleType;
	f32 CapsuleRadius;
	if (CapsuleType == 1)
	{
		f32 CapsuleHeight;
	}
	TMatrix4x4 Field8C;
	TBool8 hasName;
	if (hasName > 0)
	{
		THashString Name( version );
	}
}TEntryType2<name = "Collision Capsules">;

typedef struct{
	f32 Gravity;
	f32 Field04;

	f32 BoneThickness;
	u16 parentBone;
	u16 childBone;
}TEntryType3<name = "Bone Collections">;

typedef struct(u32 count, u32 version) {
	local u32 i<hidden=true>;
	for (i = 0; i < count; i++)
	{
		TEntryType1 entryType1(version)<read=NameToStringT1>;
	}
}TEntryType1Wrapper;

typedef struct(u32 count, u32 version) {
	local u32 i<hidden=true>;
	for (i = 0; i < count; i++)
	{
		TEntryType2 entryType2(version)<read=NameToStringT2>;
	}
}TEntryType2Wrapper;

typedef struct(u32 count) {
	local u32 i<hidden=true>;
	for (i = 0; i < count; i++)
	{
		TEntryType3 entryType3;
	}
}TEntryType3Wrapper;

string NameToStringT1( TEntryType1& value )
{
    string buffer;
	if (value.hasName > 0)
	{
		SPrintf( buffer, "%s", THashStringToString( value.Name ) );
		return buffer;
	}
	else buffer = "null";

	return buffer;
}

string NameToStringT2( TEntryType2& value )
{
    string buffer;
	if (value.hasName > 0)
	{
		SPrintf( buffer, "%s", THashStringToString( value.Name ) );
		return buffer;
	}
	else buffer = "null";

	return buffer;
}

typedef struct
{
    SetRandomBackColor();

    TChunkHeader ChunkHeader;
    TChunkTypePhysicsDictionaryHeader Header;
    TEntryType1Wrapper Type1Entries(Header.Entry1Count, ChunkHeader.Version)<name = "Bone Dictionary List">;
    TEntryType2Wrapper Type2Entries(Header.Entry2Count, ChunkHeader.Version)<name = "Collision Capsules List">;
    TEntryType3Wrapper Type3Entries(Header.Entry3Count)<name = "Bone Collections List">;
} TPhysicsDictionary <optimize=false>;
//
// -- Physics Data Chunk End --
//

typedef struct
{
    SetRandomBackColor();

    TChunkHeader Header;

    local s32 dataLength = Header.Length - 16;
    if ( dataLength > 0 )
        u8 Data[ dataLength ];
} TUnknownChunk <optimize=false>;

typedef struct
{
    SetRandomBackColor();
    TChunkHeader Header;
    Assert( Header.Type == EChunkType_EOF && Header.Length == 0 );
} TEOFChunk;

typedef struct
{
    SetRandomBackColor();
    
    if (ReadUInt() == 0x30534647) 
    {
        LittleEndian();
    }

    TFileHeader Header;

    // Read chunks
    local u32 chunkStart;
    local u32 chunkType;
    local u32 chunkLength;
    local u32 chunkEnd;

    while ( !FEof() )
    {
        chunkStart = FTell();
        chunkType = ( EChunkType )ReadInt( chunkStart + 4 );
        chunkLength = ReadInt( chunkStart + 8 );
        chunkEnd = chunkStart + chunkLength;

        switch ( chunkType )
        {
            case EChunkType_TextureDictionary:
                struct TTextureDictionary TextureDictionary;
                break;

            case EChunkType_MaterialDictionary:
                struct TMaterialDictionary MaterialDictionary;
                break;

            case EChunkType_Model:
                struct TModel Model;
                break;

            case EChunkType_AnimationPack:
                struct TAnimationPack AnimationPack;
                break;

            case EChunkType_PhysicsDictionary:
                struct TPhysicsDictionary PhysicsChunkType;
                break;

            case EChunkType_EOF:
                struct TEOFChunk EOF;
                break;

            default:
                struct TUnknownChunk UnknownChunk;
                break;
        }

        if ( chunkType == EChunkType_EOF )
            break;
    }
} TModelPackFile <optimize=false>;


//
// -- End Model pack types
//

//
// -- BED types
//

typedef enum<u32> {
    Enum0x1 = 1,
} BEDFooterFlags1;

typedef enum<u32> {
    UseFieldModelDiffuseColor = 1,
    Flags2Enum0x2 = 1 << 1,
    Flags2Enum0x4 = 1 << 2,
} BEDFooterFlags2;

typedef enum<u32> {
    Flags3Enum0x2 = 1 << 1,
} BEDFooterFlags3;

typedef enum<u32> {
    Flags4Enum0x2 = 1 << 1,
} BEDFooterFlags4;

typedef enum<u32> {
    Flags5Enum0x2 = 1 << 1,
} BEDFooterFlags5;

typedef struct {
    f32 fieldModelBrightness;
    BEDFooterFlags1 FieldModelBrightness; // 0x1, 0x2
    TColor8 FieldModelDiffuseStart;
    BEDFooterFlags2 FieldModelColorFlags;

    if ( BEDVersion >= 0x01000001 )
    {
        f32 Field94;
        BEDFooterFlags3 ENVRelatedFlag1;
        f32 Field9C; // flashes something in the field model at higher values
        BEDFooterFlags4 ENVRelatedFlag2;
        f32 ENVBrightnessIncreaseOverTime;
        BEDFooterFlags5 ENVBrightnessIncreaseFlags;
    }
    TColor8 FieldModelDiffuseEnd;
    f32 FieldB0;
    f32 FieldB4;
    u32 FieldA8;
} SkillEnvBlock;

typedef struct
{
    SetRandomBackColor();

    TFileHeader Header;
    u32 BEDVersion; // 0x00

    if ( BEDVersion > 0x01010000 )
    {
        f32 FieldBC;
        u32 FieldB8;
    }

    struct TBedList1Entry Entries( Header.Version )[3];
    SkillEnvBlock BEDEnvBlock;
} TBedFile; // btl::Skill (contained inside a btl::action::Participate::BED instance)

typedef struct( u32 version )
{
    f32 SkillDuration;
    f32 RepetitionDelay;
    f32 HitFrame;
    u32 Dummy2;
    u32 EntryCount;
    
    if ( EntryCount > 0 )
    {
        struct TBedList2Entry Entries( Header.Version )[EntryCount];
    }
} TBedList1Entry <optimize=false>; // btl::Skill::Cut

typedef enum<u16> {
    OnTarget = 0,
    BehindTarget = 1,
    BehindTarget2 = 2,
    CenterOfTargetGroup = 3,
    CenterOfSourceGroup = 4,
    CenterOfAllUnits = 5,
    OnTarget2 = 6,
    OnTarget3 = 7,
    OnTarget4 = 8,
    Origin = 9,
} SkillCutItemGroundPositionType;

typedef enum<u16> {
    Normal = 0,
    SlightlyAbove = 1,
    ModeratelyAbove = 2,
    VeryAbove = 3,
    Normal2 = 4,
} SkillCutItemVerticalPositionType;

typedef enum<u16> {
    // See 0x14099104a for available values
    // From 0 to 7, they are constant values
    // 8, 9 and 10 do a bunch of extra stuff
} SkillCutItemPositionType3;

typedef struct {
    // Most of the research done to name these fields have been through analysing FUN_140990190 on P5R.exe v1.0.1
    // As it handles reading these values and repositioning the EPL during the first frame of Skill Cut running
    SkillCutItemGroundPositionType GroundPositionShift; // seems to be a flag setting various things on first frame
    SkillCutItemVerticalPositionType VerticalPositionShift; // handles stuff regarding camera controller
    SkillCutItemPositionType3 PositionShift3; // some other position shift thing, doesn't seem to do *much*
    f32 PositionShift4; // position shift 4, doesn't seem to do anything notable
} SkillCutItemPositionAdjustments;

typedef struct( u32 version )
{
    f32 Dummy3; // something with skill duration
    SkillCutItemPositionAdjustments positionAdjustment;
    s32 Dummy8; // ???
    TEpl Epl( version );
} TBedList2Entry <optimize=false>; // btl::Skill::Cut::Item

//
// -- End BED types
//

typedef struct
{
    TFileHeader Header;
    TEpl Epl( Header.Version );
} TEplFile;

typedef struct
{
    TFileHeader Header;
    u32 Field00;
    u32 Field04;
    u32 Field08;
    u32 Field0C;
    struct TEptTexture Texture( Header.Version );
} TEptFile;

typedef struct( u32 version )
{
    SetRandomBackColor();

    THashString Name( version );
    u32 FieldU0;
    u16 FieldU1;
    ETextureFormat Format;
    u32 Size;
    u8 Data[Size];
} TEptTexture <optimize=false, read=TEptTextureToString>;

string TEptTextureToString( TEptTexture& value )
{
    string buffer;
    SPrintf( buffer, "%s (%s)", THashStringToString( value.Name ), EnumToString( value.Format ) );
    return buffer;
}

typedef struct
{
    SetRandomBackColor();
    TFileHeader Header;
    u32 Field00;
    TEplLeafCommonData5 Field04;
    TEplLeafCommonData5 Field58;
    TEplLeafCommonData5 FieldAC;
    s32 Field100;
    s32 Field104;

    if ( Field00 & 0x10000000 ) // flags?
    {
        f32 Field108;
    }

    TEplEmbeddedFile EmbeddedFile1( Header.Version ); // 0x108
    TEplEmbeddedFile EmbeddedFile2( Header.Version ); // 0x10C
} TEpdFile;

//
// -- BFL types
//
typedef struct
{
    SetRandomBackColor();
    TFileHeader Header;
    struct TBflList1Entry Normal;
    struct TBflList1Entry Danger;
    struct TBflList1Entry Holdup;
    struct TBflList1Entry BulletHail; // player anims are stuck looping through gun pull out anim
    struct TBflList1Entry CloseRange;
} TBflFile <optimize=true>;

typedef struct
{
    SetRandomBackColor();
    struct TBflList2Entry Entries[32];
} TBflList1Entry <optimize=true>;

typedef struct
{
    SetRandomBackColor();
    struct TBflList3Entry Allies[4];
    struct TBflList3Entry Enemies[5];
    u16 Field1C0;
    u16 Field1C2;
    u16 Field1C4;
    u16 Field1C6;
    struct TBflList4Entry Entries[4];
} TBflList2Entry <optimize=true>;

typedef struct
{
    SetRandomBackColor();
    u8 Field0C;
    TVector2 position;
    u16 Field00;
    f32 Field04;
    f32 Field08;
} TBflList3Entry <optimize=true, read=TVector2ToString(position)>;

typedef struct
{
    SetRandomBackColor();
    f32 Field00;
    f32 Field04;
    f32 Field08;
    f32 Field10;
    f32 Field14;
    f32 Field18;
    f32 Field20;
    f32 Field24;
} TBflList4Entry <optimize=true>;

//
// -- End BFL types
//

//
// -- ENV types
//
typedef struct
{

} TEnvFile;

//
// -- End ENV types
//

//
// -- Parse file
//
local string filePath = GetFileName();
local string fileName = FileNameGetBase( filePath, false );
local string fileExt = FileNameGetExtension( filePath );

if ( Stricmp( fileExt, ".BED" ) == 0 )
{
    TBedFile File;
}
else if ( Stricmp( fileExt, ".EPL" ) == 0 )
{
    TEplFile File;
}
else if ( Stricmp( fileExt, ".EPT" ) == 0 )
{
    TEptFile File;
}
else if ( Stricmp( fileExt, ".BFL" ) == 0 )
{
    TBflFile File;
}
//else if ( Stricmp( fileExt, ".ENV" ) == 0 )
//{
//    TEnvFile File;
//}
else
{
    TModelPackFile File <optimize=false>;
}